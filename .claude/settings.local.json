{
  "permissions": {
    "allow": [
      "Bash(node:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "WebSearch",
      "Bash(npx tsc:*)",
      "Bash(npm run build:*)",
      "Bash(for file in \"package.json\" \"tsconfig.json\" \"next.config.ts\" \"src/app/layout.tsx\" \"src/app/page.tsx\" \".env\" \".env.local\" \"src/types/index.ts\" \".gitignore\")",
      "Bash(do:*)",
      "Bash(echo:*)",
      "Bash(done)",
      "Bash(npm install:*)",
      "Bash(npx prisma generate:*)",
      "Bash(npx prisma:*)",
      "Bash(for file in \"prisma/schema.prisma\" \"prisma.config.ts\" \"src/lib/prisma.ts\" \"src/lib/rls.ts\" \"src/lib/env.ts\")",
      "Bash(npx tsx:*)",
      "Bash(ls:*)",
      "Bash(PRISMA_QUERY_ENGINE_LIBRARY=1 npx tsx:*)",
      "Bash(\"C:\\\\Users\\\\gary_\\\\OneDrive\\\\Desktop\\\\cs50\\\\gsddemo\\\\prisma\\\\migrations\\\\00000000000000_enable_rls\\\\migration.sql\" <<'EOF'\n-- Enable Row-Level Security on all tenant-scoped tables\n-- The tenants table itself does NOT need RLS \\(root entity, accessed by direct ID lookup\\)\n\n-- ============================================================\n-- USERS table: scoped by tenant_id column \\(mapped from tenantId\\)\n-- ============================================================\nALTER TABLE users ENABLE ROW LEVEL SECURITY;\nALTER TABLE users FORCE ROW LEVEL SECURITY;\n\nCREATE POLICY tenant_isolation_policy ON users\n  USING \\(\"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\\);\n\nCREATE POLICY tenant_insert_policy ON users\n  FOR INSERT\n  WITH CHECK \\(\"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\\);\n\n-- ============================================================\n-- WORKSPACES table: scoped by tenant_id column\n-- ============================================================\nALTER TABLE workspaces ENABLE ROW LEVEL SECURITY;\nALTER TABLE workspaces FORCE ROW LEVEL SECURITY;\n\nCREATE POLICY tenant_isolation_policy ON workspaces\n  USING \\(\"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\\);\n\nCREATE POLICY tenant_insert_policy ON workspaces\n  FOR INSERT\n  WITH CHECK \\(\"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\\);\n\n-- ============================================================\n-- FORMAT_SCHEMAS table: scoped by tenant_id column\n-- Note: tenantId is nullable \\(NULL = shared library schema, accessible to all\\)\n-- Policy allows access if: tenant matches OR schema is a library schema \\(tenantId IS NULL\\)\n-- ============================================================\nALTER TABLE format_schemas ENABLE ROW LEVEL SECURITY;\nALTER TABLE format_schemas FORCE ROW LEVEL SECURITY;\n\nCREATE POLICY tenant_isolation_policy ON format_schemas\n  USING \\(\n    \"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\n    OR \"tenantId\" IS NULL\n  \\);\n\nCREATE POLICY tenant_insert_policy ON format_schemas\n  FOR INSERT\n  WITH CHECK \\(\n    \"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\n    OR \"tenantId\" IS NULL\n  \\);\n\n-- ============================================================\n-- MAPPING_CONFIGS table: scoped via workspace -> tenant chain\n-- MappingConfig does not have a direct tenantId column.\n-- It is scoped through its workspace's tenantId.\n-- The subquery checks workspace ownership. This is acceptable\n-- because workspaceId is indexed and the subquery hits a PK lookup.\n-- ============================================================\nALTER TABLE mapping_configs ENABLE ROW LEVEL SECURITY;\nALTER TABLE mapping_configs FORCE ROW LEVEL SECURITY;\n\nCREATE POLICY tenant_isolation_policy ON mapping_configs\n  USING \\(\n    EXISTS \\(\n      SELECT 1 FROM workspaces\n      WHERE workspaces.id = mapping_configs.\"workspaceId\"\n      AND workspaces.\"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\n    \\)\n  \\);\n\nCREATE POLICY tenant_insert_policy ON mapping_configs\n  FOR INSERT\n  WITH CHECK \\(\n    EXISTS \\(\n      SELECT 1 FROM workspaces\n      WHERE workspaces.id = mapping_configs.\"workspaceId\"\n      AND workspaces.\"tenantId\" = current_setting\\('app.current_tenant_id', TRUE\\)\n    \\)\n  \\);\nEOF)",
      "Bash(\"C:\\\\Users\\\\gary_\\\\OneDrive\\\\Desktop\\\\cs50\\\\gsddemo\\\\prisma\\\\seed.ts\" <<'EOF'\nimport { PrismaClient } from '@prisma/client'\n\nconst prisma = new PrismaClient\\(\\)\n\nasync function main\\(\\) {\n  // Clean existing data \\(reverse dependency order\\)\n  await prisma.mappingConfig.deleteMany\\(\\)\n  await prisma.formatSchema.deleteMany\\(\\)\n  await prisma.workspace.deleteMany\\(\\)\n  await prisma.user.deleteMany\\(\\)\n  await prisma.tenant.deleteMany\\(\\)\n\n  // Tenant A: Acme Corp\n  const tenantA = await prisma.tenant.create\\({\n    data: {\n      name: 'Acme Corp',\n      slug: 'acme-corp',\n    },\n  }\\)\n\n  const userA = await prisma.user.create\\({\n    data: {\n      email: 'admin@acme.com',\n      name: 'Alice Admin',\n      role: 'admin',\n      tenantId: tenantA.id,\n    },\n  }\\)\n\n  const workspaceA = await prisma.workspace.create\\({\n    data: {\n      name: 'Acme Integrations',\n      description: 'ISO20022 to TransferMate mappings',\n      tenantId: tenantA.id,\n    },\n  }\\)\n\n  const schemaA = await prisma.formatSchema.create\\({\n    data: {\n      name: 'Acme Custom XML',\n      formatType: 'xsd',\n      schemaData: { root: 'AcmePayment', fields: ['amount', 'currency', 'date'] },\n      tenantId: tenantA.id,\n    },\n  }\\)\n\n  // Tenant B: Globex Inc\n  const tenantB = await prisma.tenant.create\\({\n    data: {\n      name: 'Globex Inc',\n      slug: 'globex-inc',\n    },\n  }\\)\n\n  const userB = await prisma.user.create\\({\n    data: {\n      email: 'admin@globex.com',\n      name: 'Bob Builder',\n      role: 'admin',\n      tenantId: tenantB.id,\n    },\n  }\\)\n\n  const workspaceB = await prisma.workspace.create\\({\n    data: {\n      name: 'Globex Payments',\n      description: 'Payment format mappings',\n      tenantId: tenantB.id,\n    },\n  }\\)\n\n  const schemaB = await prisma.formatSchema.create\\({\n    data: {\n      name: 'Globex JSON API',\n      formatType: 'json',\n      schemaData: { root: 'GlobexPayment', fields: ['total', 'curr', 'timestamp'] },\n      tenantId: tenantB.id,\n    },\n  }\\)\n\n  // Shared library schema \\(no tenant -- accessible to all\\)\n  const librarySchema = await prisma.formatSchema.create\\({\n    data: {\n      name: 'ISO20022 pacs.008',\n      formatType: 'xsd',\n      version: '2019',\n      schemaData: { root: 'Document', namespace: 'urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08' },\n      isLibrary: true,\n      tenantId: null,\n    },\n  }\\)\n\n  // Create a mapping config for Tenant A\n  await prisma.mappingConfig.create\\({\n    data: {\n      name: 'Acme XML to ISO20022',\n      description: 'Maps Acme custom payment format to ISO20022 pacs.008',\n      mappingData: { mappings: [{ source: 'amount', target: 'InstrAmt' }] },\n      status: 'draft',\n      workspaceId: workspaceA.id,\n      sourceSchemaId: schemaA.id,\n      targetSchemaId: librarySchema.id,\n      createdById: userA.id,\n    },\n  }\\)\n\n  console.log\\('Seed complete:'\\)\n  console.log\\(`  Tenant A: ${tenantA.id} \\(${tenantA.name}\\)`\\)\n  console.log\\(`  Tenant B: ${tenantB.id} \\(${tenantB.name}\\)`\\)\n  console.log\\(`  Users: ${userA.email}, ${userB.email}`\\)\n  console.log\\(`  Workspaces: ${workspaceA.name}, ${workspaceB.name}`\\)\n  console.log\\(`  Schemas: ${schemaA.name}, ${schemaB.name}, ${librarySchema.name}`\\)\n  console.log\\(`  Mapping configs: 1 \\(Acme XML to ISO20022\\)`\\)\n}\n\nmain\\(\\)\n  .catch\\(\\(e\\) => {\n    console.error\\('Seed failed:', e\\)\n    process.exit\\(1\\)\n  }\\)\n  .finally\\(async \\(\\) => {\n    await prisma.$disconnect\\(\\)\n  }\\)\nEOF)",
      "Bash(\"C:\\\\Users\\\\gary_\\\\OneDrive\\\\Desktop\\\\cs50\\\\gsddemo\\\\vercel.json\" <<'EOF'\n{\n  \"$schema\": \"https://openapi.vercel.sh/vercel.json\",\n  \"buildCommand\": \"npx prisma generate && next build\",\n  \"framework\": \"nextjs\",\n  \"installCommand\": \"npm install\"\n}\nEOF)",
      "Bash(npm run verify:rls:*)"
    ]
  }
}
