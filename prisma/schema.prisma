generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users          User[]
  workspaces     Workspace[]
  formatSchemas  FormatSchema[]
  lookupTables   LookupTable[]

  @@map("tenants")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  role      String   @default("editor")  // admin, editor, viewer
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mappingConfigs MappingConfig[] @relation("CreatedBy")

  @@index([tenantId])
  @@index([email])
  @@map("users")
}

model Workspace {
  id          String   @id @default(uuid())
  name        String
  description String?
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  mappingConfigs MappingConfig[]

  @@index([tenantId])
  @@map("workspaces")
}

model FormatSchema {
  id          String   @id @default(uuid())
  name        String
  formatType  String   // xsd, json, csv, sql, custom
  version     String?
  schemaData  Json     // Parsed schema tree structure
  isLibrary   Boolean  @default(false)  // Pre-loaded vs custom
  tenantId    String?  // Null for library schemas (shared across tenants)
  tenant      Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sourceMappings MappingConfig[] @relation("SourceSchema")
  targetMappings MappingConfig[] @relation("TargetSchema")

  @@index([tenantId])
  @@index([formatType])
  @@map("format_schemas")
}

model MappingConfig {
  id             String   @id @default(uuid())
  name           String
  description    String?
  mappingData    Json     // The actual field-to-field mapping definitions
  status         String   @default("draft")  // draft, active, archived
  workspaceId    String
  workspace      Workspace    @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  sourceSchemaId String
  sourceSchema   FormatSchema @relation("SourceSchema", fields: [sourceSchemaId], references: [id])
  targetSchemaId String
  targetSchema   FormatSchema @relation("TargetSchema", fields: [targetSchemaId], references: [id])
  createdById    String
  createdBy      User         @relation("CreatedBy", fields: [createdById], references: [id])
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  transformationRules TransformationRule[]

  @@index([workspaceId])
  @@index([sourceSchemaId])
  @@index([targetSchemaId])
  @@index([createdById])
  @@map("mapping_configs")
}

model TransformationRule {
  id              String   @id @default(uuid())
  mappingConfigId String
  type            String   // format_date, format_number, split, concatenate, conditional, lookup, constant, custom_js
  sourceFields    String[] // Array of source field paths
  targetField     String   // Target field path
  config          Json     // Type-specific configuration
  order           Int      // Execution order, 0-based
  label           String?  // Optional user-friendly label
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  mappingConfig MappingConfig @relation(fields: [mappingConfigId], references: [id], onDelete: Cascade)

  @@index([mappingConfigId])
  @@index([mappingConfigId, order])
  @@map("transformation_rules")
}

model LookupTable {
  id          String   @id @default(uuid())
  name        String   // Lookup table name (e.g., "currency_codes")
  description String?
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant  Tenant             @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  entries LookupTableEntry[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@map("lookup_tables")
}

model LookupTableEntry {
  id            String @id @default(uuid())
  lookupTableId String
  fromValue     String
  toValue       String

  lookupTable LookupTable @relation(fields: [lookupTableId], references: [id], onDelete: Cascade)

  @@unique([lookupTableId, fromValue])
  @@index([lookupTableId])
  @@map("lookup_table_entries")
}
