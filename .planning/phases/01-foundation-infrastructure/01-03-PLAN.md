---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - prisma/migrations/00000000000000_enable_rls/migration.sql
  - prisma/seed.ts
  - scripts/verify-rls.ts
  - package.json
  - vercel.json
autonomous: true
user_setup:
  - service: neon
    why: "Free-tier PostgreSQL database with RLS support and Vercel integration"
    env_vars:
      - name: DATABASE_URL
        source: "Neon Console -> Project -> Connection Details -> Connection string (pooled, with ?sslmode=require)"
      - name: DIRECT_URL
        source: "Neon Console -> Project -> Connection Details -> Connection string (direct/non-pooled, with ?sslmode=require)"
    dashboard_config:
      - task: "Create a Neon account and project"
        location: "https://console.neon.tech -> New Project -> name: messagemapper, region: US East (or closest)"

must_haves:
  truths:
    - "RLS policies are active on all tenant-scoped tables (users, workspaces, format_schemas, mapping_configs)"
    - "Queries through tenantClient only return data belonging to the specified tenant"
    - "Queries through tenantClient cannot access another tenant's data"
    - "Application can connect to Neon cloud database and run migrations"
    - "Project has Vercel deployment configuration ready"
  artifacts:
    - path: "prisma/migrations/00000000000000_enable_rls/migration.sql"
      provides: "SQL migration enabling RLS and creating tenant isolation policies on all tenant-scoped tables"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "prisma/seed.ts"
      provides: "Seed script creating two tenants with isolated data for testing"
      contains: "tenant"
    - path: "scripts/verify-rls.ts"
      provides: "Verification script proving RLS tenant isolation works end-to-end"
      contains: "tenantClient"
    - path: "vercel.json"
      provides: "Vercel deployment configuration"
      contains: "buildCommand"
  key_links:
    - from: "prisma/migrations/00000000000000_enable_rls/migration.sql"
      to: "prisma/schema.prisma"
      via: "RLS policies reference table names defined in schema (@@map values)"
      pattern: "ALTER TABLE.*tenants|users|workspaces|format_schemas|mapping_configs"
    - from: "scripts/verify-rls.ts"
      to: "src/lib/rls.ts"
      via: "Uses tenantClient factory to prove isolation"
      pattern: "import.*tenantClient.*from"
    - from: "prisma/seed.ts"
      to: "src/lib/prisma.ts"
      via: "Uses prisma singleton to insert seed data"
      pattern: "import.*prisma.*from"
---

<objective>
Apply SQL Row-Level Security policies to the database, verify tenant isolation works end-to-end, and prepare deployment configuration for Neon + Vercel.

Purpose: Plans 01-01 and 01-02 created the application scaffold, Prisma schema, and RLS client factory -- but no actual RLS policies exist in the database yet. Without SQL-level ENABLE ROW LEVEL SECURITY and CREATE POLICY statements, the tenantClient factory has nothing to enforce. This plan closes that critical gap and proves the multi-tenant isolation pattern works against a real database. It also establishes deployment readiness for free-tier cloud infrastructure (Neon for database, Vercel for application).

Output: SQL migration with RLS policies on all tenant-scoped tables, seed data for two tenants, a verification script proving cross-tenant isolation, and Vercel deployment configuration.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@prisma/schema.prisma
@src/lib/prisma.ts
@src/lib/rls.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS SQL migration and apply to Neon database</name>
  <files>
    prisma/migrations/00000000000000_enable_rls/migration.sql
    package.json
  </files>
  <action>
    PREREQUISITE: The user must have a Neon database provisioned and DATABASE_URL + DIRECT_URL set in .env.local before this task runs. The executor should check for valid connection strings in .env.local and surface the user_setup checkpoint if missing.

    1. First, run `npx prisma db push` to create all tables from the Prisma schema in the Neon database. This is a one-time baseline sync (no migration history yet). Confirm it succeeds with "Your database is now in sync with your schema."

    2. Create a custom SQL migration for RLS policies. Create the directory and file manually (not via prisma migrate) because Prisma migrate does not generate RLS statements.

    Create `prisma/migrations/00000000000000_enable_rls/migration.sql` with the following content.

    IMPORTANT: Use the lowercase @@map table names from prisma/schema.prisma (tenants, users, workspaces, format_schemas, mapping_configs), NOT the PascalCase model names. The "tenants" table does NOT get RLS because it is the root entity -- all access to tenant data is by ID lookup, not filtered by tenant context.

    ```sql
    -- Enable Row-Level Security on all tenant-scoped tables
    -- The tenants table itself does NOT need RLS (root entity, accessed by direct ID lookup)

    -- ============================================================
    -- USERS table: scoped by tenant_id column (mapped from tenantId)
    -- ============================================================
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    ALTER TABLE users FORCE ROW LEVEL SECURITY;

    CREATE POLICY tenant_isolation_policy ON users
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE));

    CREATE POLICY tenant_insert_policy ON users
      FOR INSERT
      WITH CHECK ("tenantId" = current_setting('app.current_tenant_id', TRUE));

    -- ============================================================
    -- WORKSPACES table: scoped by tenant_id column
    -- ============================================================
    ALTER TABLE workspaces ENABLE ROW LEVEL SECURITY;
    ALTER TABLE workspaces FORCE ROW LEVEL SECURITY;

    CREATE POLICY tenant_isolation_policy ON workspaces
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE));

    CREATE POLICY tenant_insert_policy ON workspaces
      FOR INSERT
      WITH CHECK ("tenantId" = current_setting('app.current_tenant_id', TRUE));

    -- ============================================================
    -- FORMAT_SCHEMAS table: scoped by tenant_id column
    -- Note: tenantId is nullable (NULL = shared library schema, accessible to all)
    -- Policy allows access if: tenant matches OR schema is a library schema (tenantId IS NULL)
    -- ============================================================
    ALTER TABLE format_schemas ENABLE ROW LEVEL SECURITY;
    ALTER TABLE format_schemas FORCE ROW LEVEL SECURITY;

    CREATE POLICY tenant_isolation_policy ON format_schemas
      USING (
        "tenantId" = current_setting('app.current_tenant_id', TRUE)
        OR "tenantId" IS NULL
      );

    CREATE POLICY tenant_insert_policy ON format_schemas
      FOR INSERT
      WITH CHECK (
        "tenantId" = current_setting('app.current_tenant_id', TRUE)
        OR "tenantId" IS NULL
      );

    -- ============================================================
    -- MAPPING_CONFIGS table: scoped via workspace -> tenant chain
    -- MappingConfig does not have a direct tenantId column.
    -- It is scoped through its workspace's tenantId.
    -- The subquery checks workspace ownership. This is acceptable
    -- because workspaceId is indexed and the subquery hits a PK lookup.
    -- ============================================================
    ALTER TABLE mapping_configs ENABLE ROW LEVEL SECURITY;
    ALTER TABLE mapping_configs FORCE ROW LEVEL SECURITY;

    CREATE POLICY tenant_isolation_policy ON mapping_configs
      USING (
        EXISTS (
          SELECT 1 FROM workspaces
          WHERE workspaces.id = mapping_configs."workspaceId"
          AND workspaces."tenantId" = current_setting('app.current_tenant_id', TRUE)
        )
      );

    CREATE POLICY tenant_insert_policy ON mapping_configs
      FOR INSERT
      WITH CHECK (
        EXISTS (
          SELECT 1 FROM workspaces
          WHERE workspaces.id = mapping_configs."workspaceId"
          AND workspaces."tenantId" = current_setting('app.current_tenant_id', TRUE)
        )
      );
    ```

    DESIGN NOTES on the SQL above:
    - FORCE ROW LEVEL SECURITY ensures policies apply even to the table owner (critical -- without FORCE, the Neon default user bypasses RLS).
    - Separate SELECT (USING) and INSERT (WITH CHECK) policies for clarity. USING covers SELECT/UPDATE/DELETE, WITH CHECK covers INSERT.
    - format_schemas allows NULL tenantId for shared library schemas (isLibrary=true).
    - mapping_configs uses a subquery through workspaces because it lacks a direct tenantId. The research warns about subquery performance (Pitfall 6), but this is a single PK lookup on an indexed column, not an N+1 pattern. Monitor in production.
    - No ::uuid cast on current_setting because Prisma uses String @id @default(uuid()), which stores UUIDs as text type in PostgreSQL.

    3. Apply the RLS migration to the database using raw SQL execution. Since this is a custom SQL file outside Prisma's migration system, execute it directly:

    ```bash
    npx prisma db execute --file prisma/migrations/00000000000000_enable_rls/migration.sql
    ```

    If this command is not available in the Prisma version, use an alternative approach:
    - Install tsx: `npm install tsx --save-dev`
    - Create a temporary script that reads the SQL file and runs it via prisma.$executeRawUnsafe()
    - Or use `psql` if available on the system

    4. Add a prisma seed script to package.json for step 2:
    ```json
    "prisma": {
      "seed": "npx tsx prisma/seed.ts"
    }
    ```

    Also add tsx as a dev dependency if not already present:
    ```bash
    npm install tsx --save-dev
    ```
  </action>
  <verify>
    Confirm RLS is active by connecting to the database and checking:
    ```bash
    npx prisma db execute --stdin <<< "SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public' AND tablename IN ('users', 'workspaces', 'format_schemas', 'mapping_configs');"
    ```
    All four tables should show rowsecurity = true.

    Also verify policies exist:
    ```bash
    npx prisma db execute --stdin <<< "SELECT tablename, policyname FROM pg_policies WHERE schemaname = 'public';"
    ```
    Should show tenant_isolation_policy and tenant_insert_policy for each of the four tables (8 policies total).
  </verify>
  <done>
    RLS is enabled and forced on users, workspaces, format_schemas, and mapping_configs tables. Eight policies exist (SELECT+INSERT for each table). The tenants table intentionally has no RLS. SQL migration file is committed at prisma/migrations/00000000000000_enable_rls/migration.sql for reproducibility. tsx is installed as a dev dependency. prisma seed command is configured in package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Seed two tenants, verify RLS isolation, and configure Vercel deployment</name>
  <files>
    prisma/seed.ts
    scripts/verify-rls.ts
    vercel.json
  </files>
  <action>
    1. Create prisma/seed.ts that inserts two tenants with users, workspaces, and format schemas. This provides test data AND proves the schema works end-to-end. Use the raw prisma client (not tenantClient) for seeding because we need to insert across tenants:

    ```typescript
    import { PrismaClient } from '@prisma/client'

    const prisma = new PrismaClient()

    async function main() {
      // Clean existing data (reverse dependency order)
      await prisma.mappingConfig.deleteMany()
      await prisma.formatSchema.deleteMany()
      await prisma.workspace.deleteMany()
      await prisma.user.deleteMany()
      await prisma.tenant.deleteMany()

      // Tenant A: Acme Corp
      const tenantA = await prisma.tenant.create({
        data: {
          name: 'Acme Corp',
          slug: 'acme-corp',
        },
      })

      const userA = await prisma.user.create({
        data: {
          email: 'admin@acme.com',
          name: 'Alice Admin',
          role: 'admin',
          tenantId: tenantA.id,
        },
      })

      const workspaceA = await prisma.workspace.create({
        data: {
          name: 'Acme Integrations',
          description: 'ISO20022 to TransferMate mappings',
          tenantId: tenantA.id,
        },
      })

      const schemaA = await prisma.formatSchema.create({
        data: {
          name: 'Acme Custom XML',
          formatType: 'xsd',
          schemaData: { root: 'AcmePayment', fields: ['amount', 'currency', 'date'] },
          tenantId: tenantA.id,
        },
      })

      // Tenant B: Globex Inc
      const tenantB = await prisma.tenant.create({
        data: {
          name: 'Globex Inc',
          slug: 'globex-inc',
        },
      })

      const userB = await prisma.user.create({
        data: {
          email: 'admin@globex.com',
          name: 'Bob Builder',
          role: 'admin',
          tenantId: tenantB.id,
        },
      })

      const workspaceB = await prisma.workspace.create({
        data: {
          name: 'Globex Payments',
          description: 'Payment format mappings',
          tenantId: tenantB.id,
        },
      })

      const schemaB = await prisma.formatSchema.create({
        data: {
          name: 'Globex JSON API',
          formatType: 'json',
          schemaData: { root: 'GlobexPayment', fields: ['total', 'curr', 'timestamp'] },
          tenantId: tenantB.id,
        },
      })

      // Shared library schema (no tenant -- accessible to all)
      const librarySchema = await prisma.formatSchema.create({
        data: {
          name: 'ISO20022 pacs.008',
          formatType: 'xsd',
          version: '2019',
          schemaData: { root: 'Document', namespace: 'urn:iso:std:iso:20022:tech:xsd:pacs.008.001.08' },
          isLibrary: true,
          tenantId: null,
        },
      })

      // Create a mapping config for Tenant A
      await prisma.mappingConfig.create({
        data: {
          name: 'Acme XML to ISO20022',
          description: 'Maps Acme custom payment format to ISO20022 pacs.008',
          mappingData: { mappings: [{ source: 'amount', target: 'InstrAmt' }] },
          status: 'draft',
          workspaceId: workspaceA.id,
          sourceSchemaId: schemaA.id,
          targetSchemaId: librarySchema.id,
          createdById: userA.id,
        },
      })

      console.log('Seed complete:')
      console.log(`  Tenant A: ${tenantA.id} (${tenantA.name})`)
      console.log(`  Tenant B: ${tenantB.id} (${tenantB.name})`)
      console.log(`  Users: ${userA.email}, ${userB.email}`)
      console.log(`  Workspaces: ${workspaceA.name}, ${workspaceB.name}`)
      console.log(`  Schemas: ${schemaA.name}, ${schemaB.name}, ${librarySchema.name}`)
      console.log(`  Mapping configs: 1 (Acme XML to ISO20022)`)
    }

    main()
      .catch((e) => {
        console.error('Seed failed:', e)
        process.exit(1)
      })
      .finally(async () => {
        await prisma.$disconnect()
      })
    ```

    Run the seed: `npx prisma db seed`

    2. Create scripts/verify-rls.ts that proves tenant isolation works. This script:
    - Imports tenantClient from src/lib/rls.ts
    - Queries as Tenant A and verifies only Tenant A data is returned
    - Queries as Tenant B and verifies only Tenant B data is returned
    - Verifies library schemas (tenantId=NULL) are visible to both tenants
    - Exits with code 0 on success, code 1 on failure

    ```typescript
    import { PrismaClient } from '@prisma/client'

    // Import the tenantClient factory -- this is what we are testing
    // Use dynamic import or direct path based on project setup
    const prisma = new PrismaClient()

    // Replicate tenantClient logic inline to avoid module resolution issues with tsx
    // This mirrors exactly what src/lib/rls.ts does
    function tenantClient(tenantId: string) {
      return prisma.$extends({
        query: {
          $allModels: {
            async $allOperations({ args, query }) {
              const [, result] = await prisma.$transaction([
                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,
                query(args),
              ])
              return result
            },
          },
        },
      })
    }

    async function verify() {
      let failures = 0

      // Get tenant IDs from the seeded data
      const tenants = await prisma.tenant.findMany({ orderBy: { name: 'asc' } })
      if (tenants.length < 2) {
        console.error('FAIL: Expected at least 2 tenants, found', tenants.length)
        console.error('Run `npx prisma db seed` first.')
        process.exit(1)
      }

      const tenantA = tenants.find(t => t.slug === 'acme-corp')!
      const tenantB = tenants.find(t => t.slug === 'globex-inc')!

      console.log(`Tenant A: ${tenantA.id} (${tenantA.name})`)
      console.log(`Tenant B: ${tenantB.id} (${tenantB.name})`)
      console.log('')

      // ---- TEST 1: Users isolation ----
      const dbA = tenantClient(tenantA.id)
      const usersA = await dbA.user.findMany()
      if (usersA.length !== 1 || usersA[0].email !== 'admin@acme.com') {
        console.error(`FAIL: Tenant A users: expected [admin@acme.com], got [${usersA.map(u => u.email)}]`)
        failures++
      } else {
        console.log('PASS: Tenant A sees only its own users')
      }

      const dbB = tenantClient(tenantB.id)
      const usersB = await dbB.user.findMany()
      if (usersB.length !== 1 || usersB[0].email !== 'admin@globex.com') {
        console.error(`FAIL: Tenant B users: expected [admin@globex.com], got [${usersB.map(u => u.email)}]`)
        failures++
      } else {
        console.log('PASS: Tenant B sees only its own users')
      }

      // ---- TEST 2: Workspaces isolation ----
      const workspacesA = await dbA.workspace.findMany()
      if (workspacesA.length !== 1 || workspacesA[0].name !== 'Acme Integrations') {
        console.error(`FAIL: Tenant A workspaces: expected [Acme Integrations], got [${workspacesA.map(w => w.name)}]`)
        failures++
      } else {
        console.log('PASS: Tenant A sees only its own workspaces')
      }

      const workspacesB = await dbB.workspace.findMany()
      if (workspacesB.length !== 1 || workspacesB[0].name !== 'Globex Payments') {
        console.error(`FAIL: Tenant B workspaces: expected [Globex Payments], got [${workspacesB.map(w => w.name)}]`)
        failures++
      } else {
        console.log('PASS: Tenant B sees only its own workspaces')
      }

      // ---- TEST 3: FormatSchemas isolation + shared library ----
      const schemasA = await dbA.formatSchema.findMany()
      const schemasANames = schemasA.map(s => s.name).sort()
      // Tenant A should see: own schema + library schema (tenantId=NULL)
      if (schemasA.length !== 2 || !schemasANames.includes('Acme Custom XML') || !schemasANames.includes('ISO20022 pacs.008')) {
        console.error(`FAIL: Tenant A schemas: expected [Acme Custom XML, ISO20022 pacs.008], got [${schemasANames}]`)
        failures++
      } else {
        console.log('PASS: Tenant A sees own schemas + shared library schemas')
      }

      const schemasB = await dbB.formatSchema.findMany()
      const schemasBNames = schemasB.map(s => s.name).sort()
      // Tenant B should see: own schema + library schema
      if (schemasB.length !== 2 || !schemasBNames.includes('Globex JSON API') || !schemasBNames.includes('ISO20022 pacs.008')) {
        console.error(`FAIL: Tenant B schemas: expected [Globex JSON API, ISO20022 pacs.008], got [${schemasBNames}]`)
        failures++
      } else {
        console.log('PASS: Tenant B sees own schemas + shared library schemas')
      }

      // ---- TEST 4: MappingConfigs isolation (via workspace) ----
      const mappingsA = await dbA.mappingConfig.findMany()
      if (mappingsA.length !== 1 || mappingsA[0].name !== 'Acme XML to ISO20022') {
        console.error(`FAIL: Tenant A mappings: expected [Acme XML to ISO20022], got [${mappingsA.map(m => m.name)}]`)
        failures++
      } else {
        console.log('PASS: Tenant A sees only its own mapping configs')
      }

      const mappingsB = await dbB.mappingConfig.findMany()
      if (mappingsB.length !== 0) {
        console.error(`FAIL: Tenant B mappings: expected [], got [${mappingsB.map(m => m.name)}]`)
        failures++
      } else {
        console.log('PASS: Tenant B sees no mapping configs (has none)')
      }

      // ---- TEST 5: Cross-tenant query returns nothing ----
      // Use a fake tenant ID -- should see nothing except library schemas
      const dbFake = tenantClient('00000000-0000-0000-0000-000000000000')
      const fakeUsers = await dbFake.user.findMany()
      const fakeWorkspaces = await dbFake.workspace.findMany()
      const fakeMappings = await dbFake.mappingConfig.findMany()
      const fakeSchemas = await dbFake.formatSchema.findMany()

      if (fakeUsers.length !== 0 || fakeWorkspaces.length !== 0 || fakeMappings.length !== 0) {
        console.error(`FAIL: Fake tenant sees data: users=${fakeUsers.length}, workspaces=${fakeWorkspaces.length}, mappings=${fakeMappings.length}`)
        failures++
      } else {
        console.log('PASS: Non-existent tenant sees no user/workspace/mapping data')
      }

      // Fake tenant should still see library schemas
      if (fakeSchemas.length !== 1 || fakeSchemas[0].name !== 'ISO20022 pacs.008') {
        console.error(`FAIL: Fake tenant schemas: expected only [ISO20022 pacs.008], got [${fakeSchemas.map(s => s.name)}]`)
        failures++
      } else {
        console.log('PASS: Non-existent tenant sees only shared library schemas')
      }

      // ---- SUMMARY ----
      console.log('')
      if (failures === 0) {
        console.log('ALL RLS TESTS PASSED -- tenant isolation is working correctly.')
      } else {
        console.error(`${failures} TEST(S) FAILED -- RLS isolation has issues.`)
        process.exit(1)
      }
    }

    verify()
      .catch((e) => {
        console.error('Verification failed with error:', e)
        process.exit(1)
      })
      .finally(async () => {
        await prisma.$disconnect()
      })
    ```

    Run the verification: `npx tsx scripts/verify-rls.ts`

    3. Create vercel.json for deployment configuration. Keep it minimal -- Vercel auto-detects Next.js projects. The config primarily ensures the build runs prisma generate before the Next.js build:

    ```json
    {
      "$schema": "https://openapi.vercel.sh/vercel.json",
      "buildCommand": "npx prisma generate && next build",
      "framework": "nextjs",
      "installCommand": "npm install"
    }
    ```

    4. Update the "scripts" in package.json to add a verify-rls convenience script:
    ```json
    "verify:rls": "tsx scripts/verify-rls.ts"
    ```

    This gives a single command (`npm run verify:rls`) to confirm RLS is working on any environment.
  </action>
  <verify>
    Run `npx prisma db seed` and confirm it completes with "Seed complete" showing two tenants, two users, two workspaces, three schemas, and one mapping config.

    Run `npm run verify:rls` (or `npx tsx scripts/verify-rls.ts`) and confirm all tests pass:
    - Tenant A sees only its own users, workspaces, schemas (+ library), and mappings
    - Tenant B sees only its own users, workspaces, schemas (+ library), and no mappings
    - Fake tenant sees nothing except library schemas
    - Output ends with "ALL RLS TESTS PASSED"

    Verify vercel.json exists and contains buildCommand with prisma generate.

    Run `npm run build` to confirm the Next.js build still passes with all new files.
  </verify>
  <done>
    Seed script creates two tenants (Acme Corp, Globex Inc) with isolated data. RLS verification script proves complete tenant isolation: each tenant only sees its own data, library schemas are shared, and non-existent tenants see nothing. vercel.json configures Vercel deployment with prisma generate in build command. The `npm run verify:rls` convenience script is available for ongoing RLS validation.
  </done>
</task>

</tasks>

<verification>
1. RLS is enabled on 4 tables: `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname='public' AND rowsecurity=true` returns users, workspaces, format_schemas, mapping_configs
2. 8 policies exist (2 per table): `SELECT count(*) FROM pg_policies WHERE schemaname='public'` returns 8
3. `npx prisma db seed` completes without errors
4. `npm run verify:rls` outputs "ALL RLS TESTS PASSED"
5. Tenant A cannot see Tenant B data and vice versa
6. Library schemas (tenantId=NULL) are visible to all tenants
7. `npm run build` passes
8. vercel.json exists with prisma generate in buildCommand
</verification>

<success_criteria>
- PostgreSQL RLS policies are active and enforced on all tenant-scoped tables
- Two-tenant seed data proves the schema works end-to-end
- Automated RLS verification script confirms tenant isolation (repeatable on any environment)
- Library schemas with null tenantId are accessible to all tenants
- Vercel deployment configuration is ready with prisma generate in build pipeline
- Application can connect to Neon free-tier database and run migrations
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
