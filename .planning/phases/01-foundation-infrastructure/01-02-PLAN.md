---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - prisma/schema.prisma
  - src/lib/prisma.ts
  - src/lib/rls.ts
  - src/lib/env.ts
autonomous: true

must_haves:
  truths:
    - "Prisma schema defines Tenant, User, Workspace, MappingConfig, and FormatSchema models with proper relations"
    - "Running prisma generate produces TypeScript types for all models"
    - "Prisma Client singleton prevents connection pool exhaustion in development"
    - "Tenant client factory wraps queries in RLS-scoped transactions"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Complete multi-tenant database schema"
      contains: "model Tenant"
    - path: "src/lib/prisma.ts"
      provides: "Prisma Client singleton with globalThis caching"
      contains: "globalForPrisma"
    - path: "src/lib/rls.ts"
      provides: "Tenant-scoped Prisma Client extension factory"
      contains: "tenantClient"
    - path: "src/lib/env.ts"
      provides: "Type-safe environment variable access"
      contains: "DATABASE_URL"
  key_links:
    - from: "src/lib/rls.ts"
      to: "src/lib/prisma.ts"
      via: "imports prisma singleton"
      pattern: "import.*prisma.*from.*./prisma"
    - from: "src/lib/rls.ts"
      to: "prisma/schema.prisma"
      via: "uses Prisma Client generated from schema"
      pattern: "\\$extends|\\$transaction"
    - from: "prisma/schema.prisma"
      to: ".env"
      via: "reads DATABASE_URL"
      pattern: "env.*DATABASE_URL"
---

<objective>
Define the complete multi-tenant database schema with Prisma and create the RLS-aware client infrastructure.

Purpose: The data model is the architectural backbone -- every feature in phases 2-10 depends on these models and the tenant isolation pattern. Getting the schema right now prevents costly migrations later. The Prisma Client singleton and RLS extension factory establish the pattern that ALL database access in the application must follow.

Output: Prisma schema with all core models, generated TypeScript types, Prisma Client singleton, and tenant-scoped client factory.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Prisma and define multi-tenant database schema</name>
  <files>
    prisma/schema.prisma
    src/lib/env.ts
  </files>
  <action>
    1. Install Prisma dependencies:
    ```bash
    npm install prisma --save-dev
    npm install @prisma/client
    ```

    2. Initialize Prisma with PostgreSQL provider:
    ```bash
    npx prisma init --datasource-provider postgresql
    ```
    This creates prisma/schema.prisma and may update .env. If it overwrites .env, restore the placeholder format from Plan 01.

    3. Replace prisma/schema.prisma with the complete multi-tenant schema. Design rationale:
    - Tenant = organization/company (top-level isolation unit)
    - User belongs to a Tenant with a role (admin/editor/viewer)
    - Workspace = a project area within a tenant for organizing mappings
    - FormatSchema = an uploaded or library format definition (XSD, JSON schema, etc.)
    - MappingConfig = a saved mapping between two FormatSchemas

    ```prisma
    generator client {
      provider = "prisma-client-js"
    }

    datasource db {
      provider = "postgresql"
      url      = env("DATABASE_URL")
      directUrl = env("DIRECT_URL")
    }

    model Tenant {
      id        String   @id @default(uuid())
      name      String
      slug      String   @unique
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt

      users          User[]
      workspaces     Workspace[]
      formatSchemas  FormatSchema[]

      @@map("tenants")
    }

    model User {
      id        String   @id @default(uuid())
      email     String   @unique
      name      String?
      role      String   @default("editor")  // admin, editor, viewer
      tenantId  String
      tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
      createdAt DateTime @default(now())
      updatedAt DateTime @updatedAt

      mappingConfigs MappingConfig[] @relation("CreatedBy")

      @@index([tenantId])
      @@index([email])
      @@map("users")
    }

    model Workspace {
      id          String   @id @default(uuid())
      name        String
      description String?
      tenantId    String
      tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
      createdAt   DateTime @default(now())
      updatedAt   DateTime @updatedAt

      mappingConfigs MappingConfig[]

      @@index([tenantId])
      @@map("workspaces")
    }

    model FormatSchema {
      id          String   @id @default(uuid())
      name        String
      formatType  String   // xsd, json, csv, sql, custom
      version     String?
      schemaData  Json     // Parsed schema tree structure
      isLibrary   Boolean  @default(false)  // Pre-loaded vs custom
      tenantId    String?  // Null for library schemas (shared across tenants)
      tenant      Tenant?  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
      createdAt   DateTime @default(now())
      updatedAt   DateTime @updatedAt

      sourceMappings MappingConfig[] @relation("SourceSchema")
      targetMappings MappingConfig[] @relation("TargetSchema")

      @@index([tenantId])
      @@index([formatType])
      @@map("format_schemas")
    }

    model MappingConfig {
      id             String   @id @default(uuid())
      name           String
      description    String?
      mappingData    Json     // The actual field-to-field mapping definitions
      status         String   @default("draft")  // draft, active, archived
      workspaceId    String
      workspace      Workspace    @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
      sourceSchemaId String
      sourceSchema   FormatSchema @relation("SourceSchema", fields: [sourceSchemaId], references: [id])
      targetSchemaId String
      targetSchema   FormatSchema @relation("TargetSchema", fields: [targetSchemaId], references: [id])
      createdById    String
      createdBy      User         @relation("CreatedBy", fields: [createdById], references: [id])
      createdAt      DateTime     @default(now())
      updatedAt      DateTime     @updatedAt

      @@index([workspaceId])
      @@index([sourceSchemaId])
      @@index([targetSchemaId])
      @@index([createdById])
      @@map("mapping_configs")
    }
    ```

    Key schema decisions:
    - Using @@map to lowercase table names (PostgreSQL convention, required for RLS policy SQL)
    - FormatSchema.tenantId is nullable -- library schemas (isLibrary=true) are shared, custom schemas belong to a tenant
    - MappingConfig stores mappingData as Json -- flexible structure for field-to-field mappings, transformations, etc.
    - Cascade deletes on tenant relations for clean tenant removal
    - Indexes on all foreign keys for query performance and RLS policy efficiency

    4. Create src/lib/env.ts for type-safe environment access:
    ```typescript
    // Type-safe environment variable access
    // Fails fast with clear error message if required vars are missing

    function getEnvVar(name: string): string {
      const value = process.env[name]
      if (!value) {
        throw new Error(
          `Missing required environment variable: ${name}. ` +
          `Check your .env.local file.`
        )
      }
      return value
    }

    export const env = {
      get DATABASE_URL() {
        return getEnvVar('DATABASE_URL')
      },
      get DIRECT_URL() {
        return getEnvVar('DIRECT_URL')
      },
      get NODE_ENV() {
        return process.env.NODE_ENV || 'development'
      },
      get IS_PRODUCTION() {
        return process.env.NODE_ENV === 'production'
      },
    } as const
    ```

    5. Run `npx prisma generate` to produce TypeScript types from the schema. This should succeed even without a database connection.
  </action>
  <verify>
    Run `npx prisma generate` and confirm it completes without errors. Run `npx prisma validate` to confirm schema is valid. Run `npx tsc --noEmit` to confirm all TypeScript compiles cleanly including the generated Prisma types.
  </verify>
  <done>prisma/schema.prisma defines Tenant, User, Workspace, FormatSchema, and MappingConfig models with proper relations, indexes, and cascade deletes. `npx prisma generate` succeeds. `npx prisma validate` passes. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create Prisma Client singleton and RLS tenant client factory</name>
  <files>
    src/lib/prisma.ts
    src/lib/rls.ts
  </files>
  <action>
    1. Create src/lib/prisma.ts with the globalThis singleton pattern to prevent connection pool exhaustion during Next.js hot reloads:

    ```typescript
    import { PrismaClient } from '@prisma/client'

    const globalForPrisma = globalThis as unknown as {
      prisma: PrismaClient | undefined
    }

    export const prisma = globalForPrisma.prisma ?? new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    })

    if (process.env.NODE_ENV !== 'production') {
      globalForPrisma.prisma = prisma
    }
    ```

    NOTE: Do NOT use PrismaPg adapter yet -- it requires an active database connection at import time. The standard PrismaClient with DATABASE_URL from env works for local dev and Neon/Supabase. The adapter can be added later if serverless connection pooling is needed.

    2. Create src/lib/rls.ts with the tenant-scoped Prisma Client extension factory. This wraps every query in a transaction that first sets the PostgreSQL runtime parameter `app.current_tenant_id`:

    ```typescript
    import { prisma } from './prisma'

    /**
     * Creates a Prisma Client that automatically scopes all queries
     * to a specific tenant using PostgreSQL Row-Level Security.
     *
     * Usage:
     *   const db = tenantClient(session.user.tenantId)
     *   const workspaces = await db.workspace.findMany() // Only returns this tenant's data
     *
     * How it works:
     * 1. Before each query, sets PostgreSQL runtime parameter `app.current_tenant_id`
     * 2. RLS policies on each table filter rows by this parameter
     * 3. All operations (SELECT, INSERT, UPDATE, DELETE) are scoped
     *
     * IMPORTANT: Never use the raw `prisma` client directly for tenant data.
     * Always use `tenantClient(tenantId)` to ensure data isolation.
     */
    export function tenantClient(tenantId: string) {
      return prisma.$extends({
        query: {
          $allModels: {
            async $allOperations({ args, query }) {
              const [, result] = await prisma.$transaction([
                prisma.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`,
                query(args),
              ])
              return result
            },
          },
        },
      })
    }

    /**
     * Type alias for the tenant-scoped Prisma Client.
     * Use this when typing function parameters that accept a tenant client.
     */
    export type TenantPrismaClient = ReturnType<typeof tenantClient>
    ```

    3. Verify both files import correctly by checking TypeScript compilation passes.

    IMPORTANT: Do NOT try to connect to a database in this task. The Prisma Client and RLS factory are code-only artifacts that will be tested against a real database in Plan 03.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm both files compile without errors. Verify src/lib/prisma.ts exports `prisma`. Verify src/lib/rls.ts exports `tenantClient` and `TenantPrismaClient`. Check that rls.ts imports from prisma.ts (not creating its own client).
  </verify>
  <done>src/lib/prisma.ts exports Prisma Client singleton with globalThis caching and dev query logging. src/lib/rls.ts exports tenantClient factory that wraps queries in RLS-scoped transactions and TenantPrismaClient type alias. Both compile cleanly. rls.ts imports from prisma.ts singleton.</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes
2. `npx prisma generate` succeeds
3. `npx tsc --noEmit` passes with zero errors
4. prisma/schema.prisma contains Tenant, User, Workspace, FormatSchema, MappingConfig models
5. src/lib/prisma.ts uses globalThis singleton pattern
6. src/lib/rls.ts uses $extends with set_config for RLS
7. All imports resolve correctly
</verification>

<success_criteria>
- Prisma schema defines 5 core models with proper relations and indexes
- prisma generate produces TypeScript types for all models
- Prisma Client singleton prevents connection pool exhaustion in dev
- Tenant client factory scopes all queries via RLS set_config
- All TypeScript compiles cleanly with strict mode
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
