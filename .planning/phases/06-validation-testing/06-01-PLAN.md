---
phase: 06-validation-testing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/validation/type-compatibility.ts
  - src/validation/required-fields.ts
  - src/validation/validate-mapping.ts
  - src/validation/index.ts
  - src/validation/__tests__/type-compatibility.test.ts
  - src/validation/__tests__/required-fields.test.ts
  - src/validation/__tests__/validate-mapping.test.ts
autonomous: true

must_haves:
  truths:
    - "Type compatibility matrix correctly identifies compatible and incompatible type pairs"
    - "Required field validation detects all unmapped required target fields"
    - "Transformation output type inference accounts for transformation chains changing types"
    - "Validation returns structured errors with field paths, error types, and severity levels"
  artifacts:
    - path: "src/validation/type-compatibility.ts"
      provides: "TYPE_COMPATIBILITY matrix, areTypesCompatible(), inferTransformationOutputType()"
      exports: ["TYPE_COMPATIBILITY", "areTypesCompatible", "inferTransformationOutputType"]
    - path: "src/validation/required-fields.ts"
      provides: "validateRequiredFields() checking all required target fields have mappings"
      exports: ["validateRequiredFields"]
    - path: "src/validation/validate-mapping.ts"
      provides: "validateMapping() orchestrating all validation checks"
      exports: ["validateMapping", "ValidationError", "ValidationResult"]
    - path: "src/validation/index.ts"
      provides: "Barrel export for validation module"
    - path: "src/validation/__tests__/type-compatibility.test.ts"
      provides: "Tests for type compatibility matrix and transformation inference"
    - path: "src/validation/__tests__/required-fields.test.ts"
      provides: "Tests for required field validation"
    - path: "src/validation/__tests__/validate-mapping.test.ts"
      provides: "Integration tests for full mapping validation"
  key_links:
    - from: "src/validation/type-compatibility.ts"
      to: "src/types/parser-types.ts"
      via: "imports FieldType"
      pattern: "import.*FieldType.*from.*parser-types"
    - from: "src/validation/validate-mapping.ts"
      to: "src/validation/type-compatibility.ts"
      via: "uses areTypesCompatible and inferTransformationOutputType"
      pattern: "import.*areTypesCompatible.*from.*type-compatibility"
    - from: "src/validation/validate-mapping.ts"
      to: "src/validation/required-fields.ts"
      via: "uses validateRequiredFields"
      pattern: "import.*validateRequiredFields.*from.*required-fields"
---

<objective>
Build the mapping validation engine using TDD: type compatibility matrix, required field validation, and transformation output type inference.

Purpose: This is the core logic for VAL-01 (type mismatch detection + required field validation). All validation UI and API layers depend on these pure functions being correct. TDD ensures comprehensive edge case coverage for type inference through transformation chains.

Output: Tested validation module at src/validation/ with type compatibility matrix, required field checker, and mapping validator.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/types/parser-types.ts
@src/types/mapping-types.ts
@src/transformations/types.ts
@src/app/mapper/lib/validation.ts
</context>

<feature>
  <name>Mapping Validation Engine</name>
  <files>
    src/validation/type-compatibility.ts
    src/validation/required-fields.ts
    src/validation/validate-mapping.ts
    src/validation/index.ts
    src/validation/__tests__/type-compatibility.test.ts
    src/validation/__tests__/required-fields.test.ts
    src/validation/__tests__/validate-mapping.test.ts
  </files>
  <behavior>
    This feature provides three validation capabilities as pure functions:

    **1. Type Compatibility (type-compatibility.ts)**

    TYPE_COMPATIBILITY matrix defines which source types can map to which target types:
    - string -> string, number, integer, boolean, date, any (string is most flexible source)
    - number -> number, integer, string, any
    - integer -> integer, number, string, any
    - boolean -> boolean, string, number, integer, any
    - date -> date, string, number, any
    - object -> object, string, any
    - array -> array, string, any
    - null -> any
    - any -> all types

    areTypesCompatible(sourceType, targetType) -> boolean
    - areTypesCompatible('string', 'string') -> true
    - areTypesCompatible('string', 'number') -> true (can parse)
    - areTypesCompatible('object', 'number') -> false
    - areTypesCompatible('any', 'boolean') -> true
    - areTypesCompatible('null', 'string') -> false

    inferTransformationOutputType(inputType, transformations) -> FieldType
    Traces through transformation chain to determine final output type:
    - inferTransformationOutputType('string', [{type: 'format_date'}]) -> 'string'
    - inferTransformationOutputType('date', [{type: 'format_date'}]) -> 'string'
    - inferTransformationOutputType('string', [{type: 'split'}]) -> 'array'
    - inferTransformationOutputType('number', [{type: 'format_number'}]) -> 'string'
    - inferTransformationOutputType('string', [{type: 'concatenate'}]) -> 'string'
    - inferTransformationOutputType('any', [{type: 'conditional'}]) -> 'any'
    - inferTransformationOutputType('string', [{type: 'constant', config: {value: 42}}]) -> 'number'
    - inferTransformationOutputType('string', [{type: 'constant', config: {value: true}}]) -> 'boolean'
    - inferTransformationOutputType('string', [{type: 'lookup'}]) -> 'string'
    - inferTransformationOutputType('string', [{type: 'custom_js'}]) -> 'any'
    - Chain: inferTransformationOutputType('number', [{type: 'format_number'}, {type: 'split'}]) -> 'array'

    **2. Required Fields (required-fields.ts)**

    validateRequiredFields(targetSchema, mappedTargetPaths) -> ValidationError[]
    - Flattens target schema tree to find all required leaf fields
    - Checks each required field path against mappedTargetPaths Set
    - Returns error for each unmapped required field

    Cases:
    - All required fields mapped -> [] (empty errors)
    - One required field unmapped -> [{type: 'missing_required', targetField: 'path', ...}]
    - Optional field unmapped -> [] (no error for optional)
    - Nested required field unmapped -> [{targetField: 'parent.child', ...}]
    - Mix of mapped and unmapped required -> errors only for unmapped

    **3. Validate Mapping (validate-mapping.ts)**

    ValidationError type:
    {
      type: 'missing_required' | 'type_mismatch',
      targetField: string,
      sourceField?: string,
      message: string,
      severity: 'error' | 'warning'
    }

    ValidationResult type:
    {
      valid: boolean,
      errors: ValidationError[],
      errorCount: number,
      warningCount: number
    }

    validateMapping(sourceSchema, targetSchema, connections) -> ValidationResult
    - Combines required field check and type compatibility check
    - For each connection: looks up source and target field, checks type compatibility
    - If connection has transformation: infers output type before checking compatibility
    - Connections use the store format: { sourceFieldPath, targetFieldPath, transformation? }

    Cases:
    - Empty connections, no required fields -> valid: true, errors: []
    - Empty connections, has required fields -> valid: false, errors: [missing_required...]
    - Compatible types connected -> valid: true
    - Incompatible types connected -> valid: false, errors: [type_mismatch]
    - Incompatible types but transformation fixes it -> valid: true
    - Multiple errors -> all collected, not just first
  </behavior>
  <implementation>
    After tests pass, implement:

    1. type-compatibility.ts:
       - Export TYPE_COMPATIBILITY as Record<FieldType, FieldType[]>
       - Export areTypesCompatible(source: FieldType, target: FieldType): boolean - lookups in matrix
       - Export inferTransformationOutputType(inputType: FieldType, transformations: Array<{type: string, config?: Record<string, unknown>}>): FieldType
       - Export inferTypeFromValue(value: unknown): FieldType helper

    2. required-fields.ts:
       - Export flattenFields(fields: FieldNode[]): FieldNode[] - recursive flattener
       - Export validateRequiredFields(targetSchema: FieldNode[], mappedTargetPaths: Set<string>): ValidationError[]
       - Only check leaf fields (no children) that are required

    3. validate-mapping.ts:
       - Import and use type-compatibility and required-fields
       - Export ValidationError and ValidationResult types
       - Export validateMapping function that combines both checks
       - Accept connections in the same format as useMappingStore connections array
       - Build field lookup maps from flattened schemas for O(1) access

    4. index.ts:
       - Barrel export all types and functions from the three modules

    Note: The existing src/app/mapper/lib/validation.ts has a simpler areTypesCompatible function used for connection-time validation. The new validation module in src/validation/ provides a more comprehensive version for post-connection analysis. Do NOT modify the existing file - the existing one gates connection creation, the new one validates the full mapping configuration.
  </implementation>
</feature>

<verification>
```bash
npm test -- --testPathPattern="src/validation" --verbose
npm run build
```
All validation tests pass. Build succeeds with no TypeScript errors.
</verification>

<success_criteria>
- All type compatibility tests pass (compatible pairs return true, incompatible pairs return false)
- Transformation output type inference correctly traces through all 8 transformation types
- Required field validation catches all unmapped required fields and ignores optional fields
- Full mapping validation combines both checks with structured error output
- Build succeeds with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-validation-testing/06-01-SUMMARY.md`
</output>
