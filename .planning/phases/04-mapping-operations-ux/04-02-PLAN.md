---
phase: 04-mapping-operations-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/mapper/store/useMappingStore.ts
  - src/app/mapper/hooks/useMappingState.ts
  - src/app/mapper/page.tsx
  - src/app/mapper/components/MappingCanvas.tsx
  - src/app/mapper/components/MappingToolbar.tsx
autonomous: true

must_haves:
  truths:
    - "User can press Ctrl+Z to undo the last mapping action (create or delete connection)"
    - "User can press Ctrl+Shift+Z to redo an undone action"
    - "Undo/redo buttons in toolbar show disabled state when history is empty"
    - "Undo/redo only tracks mapping connection changes, not UI state like expansion"
    - "Zoom and pan controls are visible and functional on the mapping canvas"
  artifacts:
    - path: "src/app/mapper/store/useMappingStore.ts"
      provides: "Zustand store with Zundo temporal middleware for mapping state"
      exports: ["useMappingStore"]
    - path: "src/app/mapper/components/MappingToolbar.tsx"
      provides: "Toolbar with undo/redo buttons"
      exports: ["MappingToolbar"]
    - path: "src/app/mapper/hooks/useMappingState.ts"
      provides: "Updated hook wrapping Zustand store for backward compatibility"
      exports: ["useMappingState", "getMappingStatus"]
    - path: "src/app/mapper/page.tsx"
      provides: "Updated page with toolbar integration"
      contains: "MappingToolbar"
  key_links:
    - from: "src/app/mapper/components/MappingToolbar.tsx"
      to: "src/app/mapper/store/useMappingStore.ts"
      via: "temporal undo/redo actions"
      pattern: "useTemporalStore|temporal"
    - from: "src/app/mapper/hooks/useMappingState.ts"
      to: "src/app/mapper/store/useMappingStore.ts"
      via: "wraps Zustand store for React Flow compatibility"
      pattern: "useMappingStore"
    - from: "src/app/mapper/page.tsx"
      to: "src/app/mapper/components/MappingToolbar.tsx"
      via: "renders toolbar in layout"
      pattern: "MappingToolbar"
---

<objective>
Add undo/redo capability for mapping actions using Zustand with Zundo temporal middleware, plus a toolbar UI.

Purpose: Users need to reverse mistakes when creating or deleting field mappings. The current React Flow hook-based state has no history tracking. Migrating to Zustand with Zundo provides automatic time-travel state management at <700 bytes overhead.

Output: Zustand store with temporal middleware, undo/redo toolbar with keyboard shortcuts, backward-compatible state hook.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-visual-mapping-interface/03-04-SUMMARY.md

# Key source files to modify/replace
@src/app/mapper/hooks/useMappingState.ts
@src/app/mapper/page.tsx
@src/app/mapper/components/MappingCanvas.tsx
@src/types/mapping-types.ts
@src/app/mapper/lib/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Zustand + Zundo, create mapping store with temporal middleware, update useMappingState hook</name>
  <files>
    src/app/mapper/store/useMappingStore.ts
    src/app/mapper/hooks/useMappingState.ts
  </files>
  <action>
1. Install dependencies:
   ```bash
   npm install zustand zundo
   ```

2. Create `src/app/mapper/store/useMappingStore.ts`:
   - 'use client' directive
   - Import `create` from 'zustand', `temporal` from 'zundo'
   - Import React Flow types: `Node, Edge`
   - Import `MappingNodeData, MappingEdgeData` from types
   - Import `FieldNode` from parser-types
   - Import `createMappingEdgeId` from validation

   Define the store interface:
   ```typescript
   interface MappingStoreState {
     // Core state (tracked by undo/redo)
     connections: Array<{
       id: string
       sourceFieldPath: string
       targetFieldPath: string
     }>

     // Schema state (NOT tracked by undo/redo)
     sourceSchema: { fields: FieldNode[]; label: string } | null
     targetSchema: { fields: FieldNode[]; label: string } | null

     // Actions
     addConnection: (sourceFieldPath: string, targetFieldPath: string) => void
     removeConnection: (id: string) => void
     removeConnections: (ids: string[]) => void
     setSourceSchema: (fields: FieldNode[], label: string) => void
     setTargetSchema: (fields: FieldNode[], label: string) => void
   }
   ```

   Create store with temporal middleware:
   ```typescript
   export const useMappingStore = create<MappingStoreState>()(
     temporal(
       (set) => ({
         connections: [],
         sourceSchema: null,
         targetSchema: null,

         addConnection: (sourceFieldPath, targetFieldPath) =>
           set((state) => ({
             connections: [
               ...state.connections,
               {
                 id: createMappingEdgeId(sourceFieldPath, targetFieldPath),
                 sourceFieldPath,
                 targetFieldPath,
               },
             ],
           })),

         removeConnection: (id) =>
           set((state) => ({
             connections: state.connections.filter((c) => c.id !== id),
           })),

         removeConnections: (ids) =>
           set((state) => ({
             connections: state.connections.filter((c) => !ids.includes(c.id)),
           })),

         setSourceSchema: (fields, label) =>
           set({ sourceSchema: { fields, label } }),

         setTargetSchema: (fields, label) =>
           set({ targetSchema: { fields, label } }),
       }),
       {
         limit: 50,
         partialize: (state) => ({
           connections: state.connections,
         }),
       }
     )
   )
   ```

   Key design decisions:
   - `connections` is the ONLY field tracked in undo/redo history via `partialize`
   - Schema changes are NOT undoable (uploading a file is not a reversible mapping action)
   - History limited to 50 entries to prevent memory bloat
   - Connections stored as plain objects (not React Flow edges) for clean separation

3. Update `src/app/mapper/hooks/useMappingState.ts`:
   - Keep this as a **bridge hook** that converts Zustand store state into React Flow-compatible format
   - Import `useMappingStore` from the store
   - Remove the existing `useNodesState` / `useEdgesState` / `addEdge` logic
   - Build React Flow `nodes` and `edges` from store state using `useMemo`:
     - `nodes`: Derive from `sourceSchema` and `targetSchema` (same node creation logic as before, positions at x:0 and x:600)
     - `edges`: Derive from `connections` array, converting each to a React Flow Edge with smoothstep type, blue stroke, animated
   - Keep `onNodesChange` using `useNodesState` for React Flow node position/selection changes (these are UI-only, not stored)
   - For `onConnect`: call `store.addConnection(connection.sourceHandle, connection.targetHandle)`
   - For `onEdgesDelete`: call `store.removeConnections(edgesToDelete.map(e => e.id))`
   - Keep `getMappingStatus` export (unchanged) and `mappedSourcePaths`/`mappedTargetPaths` derivation (unchanged logic, now derived from store connections)
   - `setSourceSchema` and `setTargetSchema` delegate to store

   IMPORTANT: Keep the same return signature from `useMappingState()` so that page.tsx and MappingCanvas.tsx continue to work without changes initially. The hook acts as an adapter between Zustand store and React Flow.

   Implementation approach:
   ```typescript
   export function useMappingState() {
     const store = useMappingStore()
     const { sourceSchema, targetSchema, connections } = store

     // Build nodes from schemas
     const schemaNodes = useMemo(() => {
       const result: Node<MappingNodeData>[] = []
       if (sourceSchema) {
         result.push({
           id: 'source-node',
           type: 'fieldTree',
           position: { x: 0, y: 0 },
           data: { side: 'source', label: sourceSchema.label, fields: sourceSchema.fields, expanded: {} },
           draggable: false,
         })
       }
       if (targetSchema) {
         result.push({
           id: 'target-node',
           type: 'fieldTree',
           position: { x: 600, y: 0 },
           data: { side: 'target', label: targetSchema.label, fields: targetSchema.fields, expanded: {} },
           draggable: false,
         })
       }
       return result
     }, [sourceSchema, targetSchema])

     // Use React Flow's nodes state for UI-level changes (position, selection)
     const [nodes, setNodes, onNodesChange] = useNodesState<Node<MappingNodeData>>(schemaNodes)

     // Sync schema changes to React Flow nodes
     useEffect(() => {
       setNodes(schemaNodes)
     }, [schemaNodes, setNodes])

     // Build edges from connections
     const edges: Edge[] = useMemo(() =>
       connections.map((conn) => ({
         id: conn.id,
         source: 'source-node',
         target: 'target-node',
         sourceHandle: conn.sourceFieldPath,
         targetHandle: conn.targetFieldPath,
         type: 'smoothstep',
         animated: true,
         style: { stroke: '#2563eb', strokeWidth: 2 },
         data: { sourceFieldPath: conn.sourceFieldPath, targetFieldPath: conn.targetFieldPath },
       })),
       [connections]
     )

     // Derive mapped paths from connections
     const mappedSourcePaths = useMemo(() => new Set(connections.map(c => c.sourceFieldPath)), [connections])
     const mappedTargetPaths = useMemo(() => new Set(connections.map(c => c.targetFieldPath)), [connections])

     const onConnect: OnConnect = useCallback((connection) => {
       if (!connection.sourceHandle || !connection.targetHandle) return
       store.addConnection(connection.sourceHandle, connection.targetHandle)
     }, [store])

     const onEdgesDelete: OnEdgesDelete = useCallback((edgesToDelete) => {
       store.removeConnections(edgesToDelete.map(e => e.id))
     }, [store])

     // Edges don't need onEdgesChange since they're derived from store
     // But React Flow expects it - provide a no-op that handles selection changes
     const onEdgesChange = useCallback(() => {}, [])

     return {
       nodes,
       edges,
       onNodesChange,
       onEdgesChange,
       setSourceSchema: store.setSourceSchema,
       setTargetSchema: store.setTargetSchema,
       onConnect,
       onEdgesDelete,
       mappedSourcePaths,
       mappedTargetPaths,
     }
   }
   ```

   CRITICAL: The return signature MUST match the existing interface used by page.tsx. If onEdgesChange needs to handle React Flow edge selection, implement it properly. But since edges are derived from store, React Flow's edge selection/removal should go through onEdgesDelete.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with zero errors
    - `npm run build` succeeds
    - Zustand and zundo appear in package.json dependencies
    - useMappingStore exports store with temporal middleware
    - useMappingState return type unchanged (backward compatible)
  </verify>
  <done>
    - Zustand + Zundo installed and listed in package.json
    - useMappingStore created with connections state, temporal middleware, 50-entry history limit
    - useMappingState updated to bridge Zustand store to React Flow format
    - Same return signature maintained for zero breaking changes to consumers
    - Schema uploads work through the bridge (setSourceSchema, setTargetSchema)
    - Connection create/delete operations go through Zustand store (undo-trackable)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MappingToolbar with undo/redo buttons and keyboard shortcuts</name>
  <files>
    src/app/mapper/components/MappingToolbar.tsx
    src/app/mapper/page.tsx
    src/app/mapper/components/MappingCanvas.tsx
  </files>
  <action>
1. Create `src/app/mapper/components/MappingToolbar.tsx`:
   - 'use client' component
   - Import `useMappingStore` from the store
   - Import `useTemporalStore` pattern from zundo (access via `useMappingStore.temporal`)

   Create a `useUndoRedo` hook inside the file (or inline):
   ```typescript
   function useUndoRedo() {
     // Access temporal store for undo/redo
     const { undo, redo, pastStates, futureStates } = useMappingStore.temporal.getState()

     // Subscribe to temporal store changes for button state
     const [canUndo, setCanUndo] = useState(false)
     const [canRedo, setCanRedo] = useState(false)

     useEffect(() => {
       // Check initial state
       const temporal = useMappingStore.temporal.getState()
       setCanUndo(temporal.pastStates.length > 0)
       setCanRedo(temporal.futureStates.length > 0)

       // Subscribe to changes
       const unsub = useMappingStore.temporal.subscribe((state) => {
         setCanUndo(state.pastStates.length > 0)
         setCanRedo(state.futureStates.length > 0)
       })

       return unsub
     }, [])

     return { undo, redo, canUndo, canRedo }
   }
   ```

   Build the toolbar component:
   ```typescript
   export function MappingToolbar() {
     const { undo, redo, canUndo, canRedo } = useUndoRedo()

     // Keyboard shortcuts
     useEffect(() => {
       function handleKeyDown(event: KeyboardEvent) {
         const isMac = navigator.platform.toUpperCase().includes('MAC')
         const modifier = isMac ? event.metaKey : event.ctrlKey

         if (modifier && event.key === 'z') {
           event.preventDefault()
           if (event.shiftKey) {
             redo()
           } else {
             undo()
           }
         }
         // Also support Ctrl+Y for redo (Windows convention)
         if (modifier && event.key === 'y') {
           event.preventDefault()
           redo()
         }
       }

       window.addEventListener('keydown', handleKeyDown)
       return () => window.removeEventListener('keydown', handleKeyDown)
     }, [undo, redo])

     return (
       <div className="flex items-center gap-2 px-4 py-2 bg-white border-b border-gray-200">
         <div className="flex items-center gap-1">
           <button
             onClick={undo}
             disabled={!canUndo}
             className="px-3 py-1.5 text-sm rounded border border-gray-300 hover:bg-gray-50 disabled:opacity-40 disabled:cursor-not-allowed flex items-center gap-1.5"
             title="Undo (Ctrl+Z)"
             aria-label="Undo last mapping action"
           >
             <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
             Undo
           </button>
           <button
             onClick={redo}
             disabled={!canRedo}
             className="px-3 py-1.5 text-sm rounded border border-gray-300 hover:bg-gray-50 disabled:opacity-40 disabled:cursor-not-allowed flex items-center gap-1.5"
             title="Redo (Ctrl+Shift+Z)"
             aria-label="Redo last undone action"
           >
             <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 1 1-2.13-9.36L23 10"/></svg>
             Redo
           </button>
         </div>
         <div className="h-6 border-l border-gray-300" />
         <span className="text-xs text-gray-500">
           {canUndo ? 'Changes tracked' : 'No changes to undo'}
         </span>
       </div>
     )
   }
   ```

   SVG icons are inline (undo = counter-clockwise arrow, redo = clockwise arrow) to avoid adding react-icons dependency for just two icons.

2. Update `src/app/mapper/page.tsx`:
   - Import `MappingToolbar`
   - Render `<MappingToolbar />` between the upload panels section and the mapping canvas section
   - Layout: toolbar sits as a horizontal bar between uploads and canvas

   Updated JSX structure:
   ```tsx
   {/* Upload Panels */}
   <div className="flex gap-4 bg-gray-50">...</div>

   {/* Mapping Toolbar */}
   <MappingToolbar />

   {/* Mapping Canvas */}
   <div className="flex-1 bg-gray-100">...</div>
   ```

3. Minor update to `src/app/mapper/components/MappingCanvas.tsx` (if needed):
   - Verify that the existing `<Controls />` component from React Flow is still rendering (it already is - provides zoom/pan buttons in bottom-left)
   - The Controls component already handles MAP-08 (zoom/pan). No changes needed unless there are issues.
   - If `onEdgesChange` from the updated hook is a no-op, ensure React Flow still handles edge selection properly. If edge selection is needed for deletion, implement a minimal onEdgesChange that handles the 'select' change type but ignores 'remove' (since removal goes through onEdgesDelete via Backspace key).

IMPORTANT: Test that the undo/redo flow works end-to-end:
- Create a connection (addConnection called via onConnect)
- Undo should remove it (temporal.undo restores previous connections state)
- Redo should re-add it (temporal.redo restores the connection)
- Edge deletion via Backspace should also be undoable
  </action>
  <verify>
    - `npx tsc --noEmit` passes with zero errors
    - `npm run build` succeeds
    - MappingToolbar renders between upload panels and canvas
    - Undo button is disabled when no history
    - Redo button is disabled when no future states
  </verify>
  <done>
    - MappingToolbar component renders with undo/redo buttons
    - Buttons show disabled state when history is empty / no future states
    - Ctrl+Z triggers undo, Ctrl+Shift+Z and Ctrl+Y trigger redo
    - Keyboard shortcuts work on both Mac (Cmd) and Windows (Ctrl)
    - Undo reverses last connection create/delete
    - Redo reapplies undone action
    - Toolbar positioned between upload panels and canvas
    - React Flow Controls component still provides zoom/pan functionality
  </done>
</task>

</tasks>

<verification>
1. Build check: `npm run build` completes without errors
2. Type check: `npx tsc --noEmit` passes
3. Package check: `zustand` and `zundo` in package.json dependencies
4. Functional: Creating a connection, pressing Ctrl+Z removes it, Ctrl+Shift+Z re-adds it
5. UI: Undo/redo buttons show correct disabled states
6. UI: Toolbar visible between upload section and canvas
7. UI: React Flow Controls (zoom/pan) still visible on canvas
8. Regression: Existing mapping creation and deletion still work
</verification>

<success_criteria>
- Zustand store manages mapping connections with temporal history
- useMappingState hook maintains backward-compatible interface while using Zustand internally
- Undo reverses connection creation and deletion
- Redo reapplies reversed actions
- Keyboard shortcuts work: Ctrl+Z (undo), Ctrl+Shift+Z (redo), Ctrl+Y (redo)
- History limited to 50 entries to prevent memory bloat
- Only connections tracked in undo history (not schema uploads or UI state)
- Toolbar shows undo/redo buttons with appropriate disabled states
- Zoom/pan controls remain functional via React Flow Controls component
</success_criteria>

<output>
After completion, create `.planning/phases/04-mapping-operations-ux/04-02-SUMMARY.md`
</output>
