---
phase: 03-visual-mapping-interface
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/mapper/page.tsx
  - src/app/mapper/components/MappingCanvas.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "After uploading a schema file, fields appear in the React Flow canvas as a tree of expandable nodes"
    - "Both source and target schemas display simultaneously in the canvas after upload"
    - "Expand/collapse, connection handles, and scroll behavior still work after the state fix"
  artifacts:
    - path: "src/app/mapper/page.tsx"
      provides: "Single useMappingState() call lifted to MapperContent, props passed down"
      contains: "useMappingState"
    - path: "src/app/mapper/components/MappingCanvas.tsx"
      provides: "Receives all state via props instead of calling useMappingState"
      contains: "MappingCanvasProps"
  key_links:
    - from: "src/app/mapper/page.tsx"
      to: "src/app/mapper/components/MappingCanvas.tsx"
      via: "Props: nodes, edges, onNodesChange, onEdgesChange, onConnect, onEdgesDelete, mappedSourcePaths, mappedTargetPaths"
      pattern: "<MappingCanvas.*nodes=|MappingCanvasProps"
    - from: "src/app/mapper/page.tsx"
      to: "src/app/mapper/components/SchemaUploadPanel.tsx"
      via: "setSourceSchema and setTargetSchema callbacks from same useMappingState instance"
      pattern: "setSourceSchema|setTargetSchema"
---

<objective>
Fix state isolation bug preventing uploaded schemas from appearing in the React Flow canvas.

Purpose: useMappingState() is called separately in MapperContent (for upload callbacks) and MappingCanvas (for rendering), creating two independent state instances. Nodes set by upload callbacks never reach the canvas. This blocks ALL visual mapping functionality -- fields, connections, status indicators.

Output: Single shared state instance with fields visible in canvas after upload.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-visual-mapping-interface/03-01-SUMMARY.md
@.planning/phases/03-visual-mapping-interface/03-02-SUMMARY.md
@.planning/debug/field-display-issue-phase-03.md
@src/app/mapper/page.tsx
@src/app/mapper/components/MappingCanvas.tsx
@src/app/mapper/hooks/useMappingState.ts
@src/types/mapping-types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lift useMappingState to MapperContent and pass state as props to MappingCanvas</name>
  <files>
    src/app/mapper/page.tsx
    src/app/mapper/components/MappingCanvas.tsx
  </files>
  <action>
**Root cause:** `useMappingState()` is called in both `MapperContent` (page.tsx) and `MappingCanvas` (MappingCanvas.tsx). React hooks create independent state per call, so the upload callbacks write to one state instance while the canvas reads from a completely separate one.

**Fix in `src/app/mapper/page.tsx`:**

1. The existing `useMappingState()` call in `MapperContent` already exists at line 10. Destructure ALL values from it, not just `setSourceSchema` and `setTargetSchema`:

```typescript
const {
  nodes,
  edges,
  onNodesChange,
  onEdgesChange,
  onConnect,
  onEdgesDelete,
  setSourceSchema,
  setTargetSchema,
  mappedSourcePaths,
  mappedTargetPaths,
} = useMappingState()
```

2. Pass all canvas-related state to `MappingCanvas` as props:

```tsx
<MappingCanvas
  nodes={nodes}
  edges={edges}
  onNodesChange={onNodesChange}
  onEdgesChange={onEdgesChange}
  onConnect={onConnect}
  onEdgesDelete={onEdgesDelete}
  mappedSourcePaths={mappedSourcePaths}
  mappedTargetPaths={mappedTargetPaths}
/>
```

3. Keep the `SchemaUploadPanel` callbacks exactly as they are -- they use `setSourceSchema` and `setTargetSchema` from the same hook instance.

**Fix in `src/app/mapper/components/MappingCanvas.tsx`:**

1. Define a `MappingCanvasProps` interface:

```typescript
import type { Node, Edge, OnNodesChange, OnEdgesChange, OnConnect, OnEdgesDelete } from '@xyflow/react'
import type { MappingNodeData } from '@/types/mapping-types'

interface MappingCanvasProps {
  nodes: Node<MappingNodeData>[]
  edges: Edge[]
  onNodesChange: OnNodesChange<Node<MappingNodeData>>
  onEdgesChange: OnEdgesChange
  onConnect: OnConnect
  onEdgesDelete: OnEdgesDelete
  mappedSourcePaths: Set<string>
  mappedTargetPaths: Set<string>
}
```

2. Change the component signature from `export function MappingCanvas()` to `export function MappingCanvas(props: MappingCanvasProps)`. Destructure props.

3. **Remove** the `useMappingState()` import and call entirely from MappingCanvas. The component should no longer call any state hook -- it receives everything via props.

4. Keep the `isValidConnection` callback -- it uses `nodes` and `edges` from props instead of from the hook. This should work identically since the variable names are the same.

5. Keep the `MappingStatusContext.Provider` wrapping ReactFlow. It now receives `mappedSourcePaths` and `mappedTargetPaths` from props.

6. Keep `nodeTypes` at module level (unchanged).

7. Keep the `isValidMappingConnection` import from `../lib/validation` (unchanged).

**What NOT to change:**
- Do NOT modify `useMappingState.ts` -- the hook itself is correct; only its usage pattern was wrong.
- Do NOT modify `FieldTreeNode.tsx`, `FieldTreeItem.tsx`, or `useFieldTree.ts` -- they are unaffected.
- Do NOT modify `SchemaUploadPanel.tsx` -- its `onSchemaLoaded` callback interface is unchanged.
- Do NOT change the `MappingStatusContext` definition -- keep it in MappingCanvas.tsx.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes with zero errors
    2. `npm run build` succeeds
    3. Verify MappingCanvas.tsx does NOT import useMappingState
    4. Verify page.tsx has exactly ONE useMappingState() call
    5. `npm run dev` -- visit http://localhost:3000/mapper:
       a. Upload a JSON sample file (e.g., sample-source-payment.json) to the Source panel
       b. Verify the source field tree appears in the React Flow canvas with visible field names
       c. Upload a file to the Target panel
       d. Verify the target field tree appears on the right side
       e. Expand/collapse fields by clicking chevrons -- verify they work
       f. Verify scrolling inside the field tree does NOT pan the canvas
  </verify>
  <done>
    After uploading schema files, fields are visible in the React Flow canvas. Both source and target trees display simultaneously. The state isolation bug is eliminated -- a single useMappingState() instance in MapperContent provides data to both upload callbacks and the canvas. All existing functionality (expand/collapse, handles, scroll isolation) is preserved.
  </done>
</task>

</tasks>

<verification>
Gap closure verification:
1. [GAP-1] "After upload, the panel should show the parsed schema as a React Flow node with a field count indicator and visible fields" -- CLOSED by lifting state to single instance
2. [UAT-1] Upload and Display Schema Files -- fields now visible after upload
3. [UAT-3 through UAT-7] Previously skipped tests -- now unblocked for testing (these are covered by the existing 03-03 plan or re-UAT)
</verification>

<success_criteria>
- Field trees visible in React Flow canvas after file upload (the failed UAT test)
- Single useMappingState() call in entire component tree (no duplicate state)
- TypeScript strict mode compilation passes
- Production build succeeds
- All 5 previously-skipped UAT tests are now unblocked for testing
</success_criteria>

<output>
After completion, create `.planning/phases/03-visual-mapping-interface/03-04-SUMMARY.md`
</output>
