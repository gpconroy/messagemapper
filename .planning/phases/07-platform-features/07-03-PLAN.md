---
phase: 07-platform-features
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - src/app/(protected)/dashboard/page.tsx
  - src/app/(protected)/dashboard/actions.ts
  - src/app/(protected)/layout.tsx
  - src/app/(protected)/admin/members/page.tsx
  - src/app/(protected)/admin/members/actions.ts
  - src/app/(protected)/workspace/[workspaceId]/page.tsx
  - src/app/(protected)/workspace/[workspaceId]/actions.ts
autonomous: true

must_haves:
  truths:
    - "Admin can assign roles (admin, editor, viewer) to users in their organization"
    - "Each organization has isolated workspaces that other organizations cannot access"
    - "User can create, rename, and organize mapping configurations within workspaces"
    - "Editor role can create and edit mappings while viewer role has read-only access"
  artifacts:
    - path: "src/app/(protected)/dashboard/page.tsx"
      provides: "Dashboard showing workspaces and workspace creation"
      min_lines: 40
    - path: "src/app/(protected)/dashboard/actions.ts"
      provides: "Server Actions for workspace CRUD"
      exports: ["createWorkspace", "renameWorkspace", "deleteWorkspace"]
    - path: "src/app/(protected)/layout.tsx"
      provides: "Protected layout with auth check and navigation"
      min_lines: 20
    - path: "src/app/(protected)/admin/members/page.tsx"
      provides: "Admin page for managing organization members and roles"
      min_lines: 40
    - path: "src/app/(protected)/admin/members/actions.ts"
      provides: "Server Actions for role assignment and member invite"
      exports: ["updateUserRole", "inviteUser"]
    - path: "src/app/(protected)/workspace/[workspaceId]/page.tsx"
      provides: "Workspace detail page showing mapping configs"
      min_lines: 40
    - path: "src/app/(protected)/workspace/[workspaceId]/actions.ts"
      provides: "Server Actions for mapping config management within workspace"
      exports: ["createMappingConfig", "renameMappingConfig", "deleteMappingConfig"]
  key_links:
    - from: "src/app/(protected)/dashboard/actions.ts"
      to: "src/lib/rls.ts"
      via: "tenantQuery for workspace CRUD"
      pattern: "tenantQuery"
    - from: "src/app/(protected)/admin/members/actions.ts"
      to: "src/lib/auth/rbac.ts"
      via: "requireRole for admin-only access"
      pattern: "requireRole"
    - from: "src/app/(protected)/workspace/[workspaceId]/actions.ts"
      to: "src/lib/auth/rbac.ts"
      via: "canEdit for role-based write control"
      pattern: "canEdit"
    - from: "src/app/(protected)/layout.tsx"
      to: "src/auth.ts"
      via: "auth() session check"
      pattern: "auth\\(\\)"
---

<objective>
Implement RBAC role management, workspace CRUD, and mapping configuration organization within workspaces.

Purpose: This plan delivers the multi-tenant workspace experience (PLAT-04, PLAT-05, PLAT-06, PLAT-08). Admins can manage team roles, all users see their org's workspaces, and editors/admins can create and organize mapping configurations within workspaces. Data isolation is enforced via the existing RLS infrastructure.

Output: Dashboard with workspace list/create, admin member management page, workspace detail page with mapping config list/create/rename/delete.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-platform-features/07-RESEARCH.md
@.planning/phases/07-platform-features/07-01-SUMMARY.md
@.planning/phases/07-platform-features/07-02-SUMMARY.md
@src/auth.ts
@src/lib/rls.ts
@src/lib/auth/rbac.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protected layout, dashboard with workspace CRUD, and admin member management</name>
  <files>
    src/app/(protected)/layout.tsx
    src/app/(protected)/dashboard/page.tsx
    src/app/(protected)/dashboard/actions.ts
    src/app/(protected)/admin/members/page.tsx
    src/app/(protected)/admin/members/actions.ts
  </files>
  <action>
1. Create `src/app/(protected)/layout.tsx`:
   - This is a Server Component (no "use client")
   - Import auth from "@/auth", redirect from "next/navigation"
   - Call const session = await auth(). If !session?.user, redirect("/login")
   - Render a layout with:
     - Green header bar matching existing app style (bg-green-600): "MessageMapper" title, navigation links (Dashboard, if admin: Members), user info (name, role badge), LogoutButton
     - Import LogoutButton from "@/components/LogoutButton"
     - Main content area: {children}
   - Pass session to header for displaying user name and role

2. Create `src/app/(protected)/dashboard/actions.ts`:
   - "use server" directive
   - Import auth from "@/auth", tenantQuery from "@/lib/rls", z from "zod", revalidatePath from "next/cache"

   a) Export async function createWorkspace(prevState: any, formData: FormData):
      - Get session, verify authenticated and has tenantId
      - Verify role is admin or editor (viewers cannot create workspaces)
      - Validate: name z.string().min(1).max(100), description z.string().optional()
      - Use tenantQuery(session.user.tenantId, ...) to create workspace with name, description, tenantId
      - revalidatePath("/dashboard")
      - Return { success: true, workspaceId: workspace.id }

   b) Export async function renameWorkspace(prevState: any, formData: FormData):
      - Get session, verify auth
      - Validate: workspaceId z.string().uuid(), name z.string().min(1).max(100)
      - Use tenantQuery to update workspace name (RLS ensures tenant isolation)
      - revalidatePath("/dashboard")
      - Return { success: true }

   c) Export async function deleteWorkspace(workspaceId: string):
      - Get session, verify auth and admin role
      - Use tenantQuery to delete workspace (cascade deletes mapping configs)
      - revalidatePath("/dashboard")

3. Create `src/app/(protected)/dashboard/page.tsx`:
   - Server Component
   - Import auth from "@/auth", tenantQuery from "@/lib/rls", redirect from "next/navigation"
   - Get session. If !session?.user?.tenantId, redirect("/login")
   - Load workspaces via tenantQuery: db.workspace.findMany({ orderBy: { createdAt: "desc" }, include: { _count: { select: { mappingConfigs: true } } } })
   - Render:
     - Page heading: "Workspaces" with subtitle showing org name
     - "New Workspace" button/form (only if canEdit(session.user.role))
     - Grid of workspace cards (3 cols on lg, 1 on mobile): workspace name, description, mapping count, createdAt date, link to /workspace/[id]
     - Empty state: "No workspaces yet. Create one to get started."
   - The "New Workspace" form can be a simple inline form or modal. Use a client component wrapper with useActionState for the create form.

4. Create `src/app/(protected)/admin/members/actions.ts`:
   - "use server" directive
   - Import auth from "@/auth", tenantQuery from "@/lib/rls", requireRole from "@/lib/auth/rbac", hashPassword from "@/lib/auth/passwords"

   a) Export async function updateUserRole(prevState: any, formData: FormData):
      - const session = await requireRole(["admin"]) -- only admins can change roles
      - Validate: userId z.string().uuid(), role z.enum(["admin", "editor", "viewer"])
      - Prevent admin from changing their own role (safety check)
      - Use tenantQuery to update user role (RLS ensures same-tenant only)
      - revalidatePath("/admin/members")
      - Return { success: true }

   b) Export async function inviteUser(prevState: any, formData: FormData):
      - const session = await requireRole(["admin"])
      - Validate: email z.string().email(), name z.string().min(1), role z.enum(["admin", "editor", "viewer"])
      - Generate a temporary password (crypto.randomUUID().slice(0, 12)) -- this is a simplified invite; user will need to change password later
      - Check if email already exists (return error if so)
      - Hash the temporary password
      - Use prisma (NOT tenantQuery, since we need to create in the users table which may not have RLS on insert) to create user with email, name, passwordHash, role, tenantId=session.user.tenantId
      - revalidatePath("/admin/members")
      - Return { success: true, temporaryPassword } -- display this once to the admin

5. Create `src/app/(protected)/admin/members/page.tsx`:
   - Server Component
   - Import requireRole from "@/lib/auth/rbac", tenantQuery from "@/lib/rls"
   - Call await requireRole(["admin"]) -- redirects non-admins
   - Load org members: tenantQuery(session.user.tenantId, db => db.user.findMany({ orderBy: { createdAt: "desc" } }))
   - Render:
     - Page heading: "Organization Members"
     - "Invite Member" form (email, name, role selector)
     - Table of members: name, email, role (with dropdown to change), joined date
     - Role dropdown calls updateUserRole action
     - Current user's row is highlighted, role dropdown disabled (can't change own role)
   - Use client component wrappers for interactive elements (role dropdown, invite form)

IMPORTANT NOTES:
- All workspace operations use tenantQuery() for RLS enforcement. Never use bare prisma for tenant data.
- The (protected) route group doesn't add a URL segment. /dashboard and /admin/members are the actual URLs.
- canEdit helper from rbac.ts determines if user can create/modify content.
- For the invite flow, we create the user directly with a temp password. This is simpler than an email invite system (which is deferred per research open questions).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` completes
    - All page and action files exist in correct directories
    - Dashboard page loads workspaces via tenantQuery
    - Admin members page calls requireRole(["admin"])
    - Workspace CRUD actions use tenantQuery for tenant isolation
  </verify>
  <done>Protected layout with auth-aware navigation. Dashboard shows workspace grid with create/rename capability. Admin members page allows role assignment (admin/editor/viewer) and user invitation. All data access goes through tenantQuery for RLS enforcement.</done>
</task>

<task type="auto">
  <name>Task 2: Create workspace detail page with mapping config management</name>
  <files>
    src/app/(protected)/workspace/[workspaceId]/page.tsx
    src/app/(protected)/workspace/[workspaceId]/actions.ts
  </files>
  <action>
1. Create `src/app/(protected)/workspace/[workspaceId]/actions.ts`:
   - "use server" directive
   - Import auth from "@/auth", tenantQuery from "@/lib/rls", z from "zod", revalidatePath from "next/cache"

   a) Export async function createMappingConfig(prevState: any, formData: FormData):
      - Get session, verify auth
      - Verify canEdit(session.user.role) -- viewers cannot create
      - Validate: name z.string().min(1).max(200), description z.string().optional(), workspaceId z.string().uuid()
      - Use tenantQuery to:
        - Verify workspace exists and belongs to tenant
        - Create MappingConfig with name, description, workspaceId, createdById=session.user.id, status="draft", mappingData={} (empty JSON), sourceSchemaId and targetSchemaId will be null initially -- BUT check schema: if these are required non-nullable fields, we need placeholder schemas or make them nullable
        - IMPORTANT: Check prisma schema -- sourceSchemaId and targetSchemaId are required String fields. For a new empty mapping config, we need to handle this. Options:
          1. Make them optional in schema (prisma migrate)
          2. Create mapping config only when schemas are uploaded
          3. Use a sentinel/placeholder value
        - Best approach: Create the mapping config when the user first saves from the mapper (Plan 04 handles save/load). For NOW, this action creates a mapping config "stub" that will link schemas later. To avoid the FK constraint issue, make sourceSchemaId and targetSchemaId optional in the schema. Add a prisma migration for this.
        - ACTUALLY: Since modifying the schema is complex at this point, instead only allow creating a mapping config WITH source/target schemas already selected. The "New Mapping" button can open a dialog that lets user select existing schemas, or the mapping is created from the mapper page after uploading files.
        - SIMPLEST approach for this plan: The createMappingConfig action accepts workspaceId only and shows in the workspace as a "stub" or we defer actual MappingConfig creation to Plan 04 save flow. For this task, focus on listing and renaming existing configs.
      - For now: Skip createMappingConfig that requires schemas. Instead, the workspace page shows existing mapping configs and allows rename/delete. The actual creation happens in Plan 04 when saving from the mapper.

   b) Export async function renameMappingConfig(prevState: any, formData: FormData):
      - Get session, verify canEdit
      - Validate: mappingConfigId z.string().uuid(), name z.string().min(1).max(200)
      - Use tenantQuery to update the mapping config name (the workspace and its configs are tenant-scoped via RLS)
      - revalidatePath for the workspace page
      - Return { success: true }

   c) Export async function deleteMappingConfig(mappingConfigId: string, workspaceId: string):
      - Get session, verify canEdit
      - Use tenantQuery to delete the mapping config
      - revalidatePath for the workspace page

2. Create `src/app/(protected)/workspace/[workspaceId]/page.tsx`:
   - Server Component
   - Import auth from "@/auth", tenantQuery from "@/lib/rls", redirect and notFound from "next/navigation"
   - Handle Next.js 15+ async params: const { workspaceId } = await params
   - Get session, verify auth
   - Load workspace with mapping configs via tenantQuery:
     ```
     db.workspace.findUnique({
       where: { id: workspaceId },
       include: {
         mappingConfigs: {
           orderBy: { updatedAt: "desc" },
           include: { createdBy: { select: { name: true, email: true } } }
         }
       }
     })
     ```
   - If workspace not found: notFound()
   - Determine canEdit from session.user.role
   - Render:
     - Breadcrumb: Dashboard > Workspace Name
     - Workspace heading with name and description
     - "Open Mapper" button that links to /mapper (existing page -- Plan 04 will add workspace context)
     - Grid/list of mapping configurations: name, status badge (draft/active/archived), created by, last updated, source/target schema names
     - Each config has: rename action (inline edit, canEdit only), delete button (canEdit only), "Open" link to load in mapper
     - Empty state: "No mapping configurations yet. Open the mapper to create one."
   - Viewers see the list but no edit/delete controls

IMPORTANT NOTES:
- Next.js 15+ params are async: `const { workspaceId } = await params` (this was a gotcha in Phase 5)
- All queries go through tenantQuery for RLS. If user accesses a workspace from a different tenant, RLS returns null and we show notFound().
- The actual "save mapping" flow (PLAT-07) is handled in Plan 04 which connects the mapper to workspace/mapping persistence.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` completes
    - Workspace detail page loads at /workspace/[id]
    - Mapping configs listed with rename/delete controls for editors
    - Viewers see read-only list
    - All queries use tenantQuery
  </verify>
  <done>Workspace detail page shows mapping configurations with metadata. Editors can rename and delete configs. Viewers see read-only list. RLS enforces tenant isolation. Ready for Plan 04 to connect mapper save/load.</done>
</task>

</tasks>

<verification>
- Admin can navigate to /admin/members and see org members with role dropdowns
- Admin can change another user's role between admin/editor/viewer
- Admin can invite new user with temporary password
- Dashboard shows workspace cards with create button for editors+admins
- Workspace detail page lists mapping configs with edit controls for editors
- Viewer role sees no create/edit/delete controls
- All data queries use tenantQuery for RLS enforcement
</verification>

<success_criteria>
RBAC, workspace management, and mapping config organization are functional. Admins manage roles (PLAT-04). Workspaces are tenant-isolated (PLAT-05). Mapping configs can be organized within workspaces (PLAT-06). Editors can modify, viewers are read-only (PLAT-08).
</success_criteria>

<output>
After completion, create `.planning/phases/07-platform-features/07-03-SUMMARY.md`
</output>
