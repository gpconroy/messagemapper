---
phase: 07-platform-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/auth.ts
  - src/lib/auth/passwords.ts
  - src/lib/auth/rbac.ts
  - src/lib/auth/types.ts
  - src/app/api/auth/[...nextauth]/route.ts
  - src/middleware.ts
  - .env.local
autonomous: true

must_haves:
  truths:
    - "Auth.js v5 is configured with credentials provider and JWT sessions"
    - "Passwords are hashed with Argon2id, not stored in plaintext"
    - "Protected routes redirect unauthenticated users to /login"
    - "Session contains user role and tenantId for downstream use"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "User model with passwordHash field"
      contains: "passwordHash"
    - path: "src/auth.ts"
      provides: "Auth.js v5 configuration with credentials provider"
      exports: ["handlers", "auth", "signIn", "signOut"]
    - path: "src/lib/auth/passwords.ts"
      provides: "Argon2id password hash and verify functions"
      exports: ["hashPassword", "verifyPassword"]
    - path: "src/lib/auth/rbac.ts"
      provides: "Role checking utility"
      exports: ["requireRole"]
    - path: "src/app/api/auth/[...nextauth]/route.ts"
      provides: "Auth.js API route handler"
      exports: ["GET", "POST"]
    - path: "src/middleware.ts"
      provides: "Route protection middleware"
  key_links:
    - from: "src/auth.ts"
      to: "src/lib/auth/passwords.ts"
      via: "verifyPassword in authorize callback"
      pattern: "verifyPassword"
    - from: "src/auth.ts"
      to: "prisma.user"
      via: "findUnique in authorize callback"
      pattern: "prisma\\.user\\.findUnique"
    - from: "src/middleware.ts"
      to: "src/auth.ts"
      via: "auth() wrapper for middleware"
      pattern: "import.*auth.*from.*@/auth"
---

<objective>
Set up Auth.js v5 authentication infrastructure with credentials provider, Argon2id password hashing, JWT sessions carrying role and tenantId, and middleware-based route protection.

Purpose: This is the foundation that all other Phase 7 plans depend on. Without auth configuration, no signup/login flows, RBAC, or workspace management can function. It also adds the missing passwordHash field to the User model.

Output: Auth.js config, password utilities, route protection middleware, updated Prisma schema with passwordHash.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-platform-features/07-RESEARCH.md
@prisma/schema.prisma
@src/lib/rls.ts
@src/lib/prisma.ts
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install auth dependencies and update Prisma schema</name>
  <files>
    package.json
    prisma/schema.prisma
  </files>
  <action>
1. Install required packages:
   ```
   npm install next-auth@beta @auth/prisma-adapter @node-rs/argon2
   ```
   NOTE: next-auth@beta is Auth.js v5 -- the package name is still "next-auth" on npm but the import paths are Auth.js v5 style.

2. Add `passwordHash` field to the User model in `prisma/schema.prisma`:
   ```
   passwordHash String?  // Argon2id hash, nullable for future OAuth users
   ```
   Add it after the `name` field. Keep it nullable (String?) so OAuth users without passwords can exist in the future.

3. Also add `emailVerified DateTime?` field to User model if needed by Auth.js PrismaAdapter. Check if @auth/prisma-adapter requires Account/Session/VerificationToken models. If so, do NOT add them -- we are using JWT sessions with credentials provider only, so the adapter is used only for User lookup. If the adapter strictly requires those models, skip using the adapter entirely and use direct Prisma queries in the authorize callback instead.

4. Run `npx prisma db push` to apply the schema change. If this fails due to permissions (the app_user role may not have ALTER TABLE), use the neondb_owner connection string from DIRECT_URL instead: `npx prisma db push --force-reset` is NOT acceptable. Instead, try with the default connection. If it fails, note the issue for manual resolution.

5. Generate updated Prisma client: `npx prisma generate`

IMPORTANT: Do NOT add Account, Session, or VerificationToken models. We use JWT strategy exclusively. The credentials provider does not need database sessions.
  </action>
  <verify>
    - `npx prisma validate` passes without errors
    - `npx prisma generate` completes successfully
    - `npm ls next-auth` shows next-auth@5.x installed
    - `npm ls @node-rs/argon2` shows argon2 installed
  </verify>
  <done>User model has passwordHash field, all auth packages installed, Prisma client regenerated.</done>
</task>

<task type="auto">
  <name>Task 2: Create Auth.js configuration, password utilities, and middleware</name>
  <files>
    src/auth.ts
    src/lib/auth/passwords.ts
    src/lib/auth/rbac.ts
    src/lib/auth/types.ts
    src/app/api/auth/[...nextauth]/route.ts
    src/middleware.ts
    .env.local
  </files>
  <action>
1. Create `src/lib/auth/passwords.ts`:
   - Export `hashPassword(password: string): Promise<string>` using `@node-rs/argon2` hash with config: memoryCost=65536, timeCost=3, parallelism=4
   - Export `verifyPassword(password: string, hash: string): Promise<boolean>` using `@node-rs/argon2` verify, wrapped in try/catch returning false on error
   - Import `hash` and `verify` from `@node-rs/argon2`

2. Create `src/lib/auth/types.ts`:
   - Extend the Auth.js session types using module augmentation:
     ```typescript
     import "next-auth"
     declare module "next-auth" {
       interface Session {
         user: {
           id: string
           email: string
           name: string | null
           role: string
           tenantId: string
         }
       }
       interface User {
         role: string
         tenantId: string
       }
     }
     import "next-auth/jwt"
     declare module "next-auth/jwt" {
       interface JWT {
         role: string
         tenantId: string
       }
     }
     ```

3. Create `src/lib/auth/rbac.ts`:
   - Export type `Role = "admin" | "editor" | "viewer"`
   - Export `async function requireRole(allowedRoles: Role[])` that calls `auth()` from `@/auth`, redirects to `/login` if no session, redirects to `/unauthorized` if role not in allowedRoles, returns session if authorized
   - Export `function canEdit(role: string): boolean` that returns true if role is "admin" or "editor"

4. Create `src/auth.ts` (project root of src/):
   - Import NextAuth from "next-auth"
   - Import Credentials from "next-auth/providers/credentials"
   - Import prisma from "@/lib/prisma"
   - Import verifyPassword from "@/lib/auth/passwords"
   - Import "./lib/auth/types" for type augmentation side effect
   - Import zod for credentials validation
   - Configure:
     - session: { strategy: "jwt", maxAge: 7 * 24 * 60 * 60 } (7 days)
     - pages: { signIn: "/login" }
     - Do NOT use PrismaAdapter (credentials provider with JWT doesn't need it; the adapter requires Account/Session models we don't have)
     - Credentials provider with email+password fields
     - authorize: validate with zod (email: z.string().email(), password: z.string().min(8)), find user by email with prisma.user.findUnique including tenant, verify password, return user object with id, email, name, role, tenantId (or null on failure). Wrap in try/catch, return null on any error.
     - jwt callback: if user exists (login event), set token.role = user.role, token.tenantId = user.tenantId, token.id = user.id
     - session callback: set session.user.role from token.role, session.user.tenantId from token.tenantId, session.user.id from token.id (as string)
   - Export { handlers, auth, signIn, signOut }

5. Create `src/app/api/auth/[...nextauth]/route.ts`:
   ```typescript
   import { handlers } from "@/auth"
   export const { GET, POST } = handlers
   ```

6. Create `src/middleware.ts` (project root, NOT inside src/app):
   IMPORTANT: middleware.ts goes at the project root OR in src/ depending on Next.js config. Since the project uses src/ directory, place it at `src/middleware.ts`.
   - Import auth from "@/auth"
   - Use the auth() wrapper pattern from Auth.js v5:
     ```typescript
     export default auth((req) => { ... })
     ```
   - Logic:
     - Public routes: /login, /signup, /api/auth/* -- allow through without auth
     - If not authenticated and not on public route: redirect to /login with callbackUrl
     - If authenticated and on /login or /signup: redirect to /dashboard
     - Otherwise: NextResponse.next()
   - matcher config: exclude _next/static, _next/image, favicon.ico, and public assets
   - ALSO allow the existing /mapper route through for now (it will be protected once workspace routing is set up in Plan 04)

7. Add NEXTAUTH_SECRET to `.env.local`:
   - Generate a random secret: use `openssl rand -base64 32` via bash, or generate a UUID-based string
   - Add: `NEXTAUTH_SECRET=<generated-value>`
   - Add: `NEXTAUTH_URL=http://localhost:3000`

CRITICAL NOTES:
- The @node-rs/argon2 package uses native bindings. If it fails to install (platform issue), fall back to the `argon2` npm package instead which has the same API but is pure JS.
- Do NOT use bcrypt. The research specifies Argon2id as the 2026 standard.
- The middleware must NOT block /api/auth/* routes or Auth.js will not function.
- Do NOT use `import { auth } from "next-auth"` -- use `import { auth } from "@/auth"` (local config).
  </action>
  <verify>
    - `npx tsc --noEmit` passes (TypeScript compilation check)
    - All files exist: src/auth.ts, src/lib/auth/passwords.ts, src/lib/auth/rbac.ts, src/lib/auth/types.ts, src/app/api/auth/[...nextauth]/route.ts, src/middleware.ts
    - `npm run build` completes without errors (or at least no auth-related errors)
  </verify>
  <done>Auth.js v5 configured with credentials provider and JWT sessions. Password utilities use Argon2id. Middleware redirects unauthenticated users to /login. Session carries role and tenantId. NEXTAUTH_SECRET set in .env.local.</done>
</task>

</tasks>

<verification>
- `npx prisma validate` confirms schema is valid
- `npx tsc --noEmit` confirms TypeScript compiles
- Auth.js route handler exists at /api/auth/*
- Middleware file exists and imports from @/auth
- Password utility exports hashPassword and verifyPassword
- RBAC utility exports requireRole and canEdit
</verification>

<success_criteria>
Auth infrastructure is in place: Auth.js v5 configured, passwords hashed with Argon2id, middleware protects routes, session carries role+tenantId. Ready for Plan 02 to build signup/login UI on top.
</success_criteria>

<output>
After completion, create `.planning/phases/07-platform-features/07-01-SUMMARY.md`
</output>
