---
phase: 05-transformation-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/app/api/transformations/route.ts
  - src/app/api/lookup-tables/route.ts
  - src/app/api/lookup-tables/[id]/entries/route.ts
autonomous: true

must_haves:
  truths:
    - "Transformation rules can be stored and retrieved per mapping configuration"
    - "Lookup tables can be created and managed per tenant with from/to value entries"
    - "Transformation rules are ordered for deterministic pipeline execution"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "TransformationRule and LookupTable models with proper relations and indexes"
      contains: "model TransformationRule"
    - path: "src/app/api/transformations/route.ts"
      provides: "CRUD API for transformation rules on a mapping"
      exports: ["GET", "POST"]
    - path: "src/app/api/lookup-tables/route.ts"
      provides: "CRUD API for lookup tables"
      exports: ["GET", "POST"]
    - path: "src/app/api/lookup-tables/[id]/entries/route.ts"
      provides: "CRUD API for lookup table entries"
      exports: ["GET", "POST", "PUT", "DELETE"]
  key_links:
    - from: "prisma/schema.prisma"
      to: "src/app/api/transformations/route.ts"
      via: "Prisma client for TransformationRule CRUD"
      pattern: "prisma\\.transformationRule"
    - from: "prisma/schema.prisma"
      to: "src/app/api/lookup-tables/route.ts"
      via: "Prisma client for LookupTable CRUD"
      pattern: "prisma\\.lookupTable"
---

<objective>
Add database models and API routes for transformation rules and lookup tables, enabling persistent storage of transformation configurations per mapping and tenant-scoped code translation tables.

Purpose: Provides the data layer for all transformation types (XFRM-01 through XFRM-07) and specifically the lookup table CRUD for XFRM-06. Transformation rules link to MappingConfig and store typed JSON configuration. Lookup tables are tenant-scoped with RLS for multi-tenant isolation.

Output: Two new Prisma models with migrations applied, plus REST API routes for CRUD operations.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-transformation-system/05-RESEARCH.md
@prisma/schema.prisma
@src/lib/prisma.ts
@src/lib/rls.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TransformationRule and LookupTable models to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
    Add two new models to prisma/schema.prisma:

    **TransformationRule model:**
    - id: String @id @default(uuid())
    - mappingConfigId: String (FK to MappingConfig)
    - type: String (transformation type: format_date, format_number, split, concatenate, conditional, lookup, constant, custom_js)
    - sourceFields: String[] (array of source field paths)
    - targetField: String (target field path)
    - config: Json (type-specific configuration)
    - order: Int (execution order, 0-based)
    - label: String? (optional user-friendly label)
    - createdAt: DateTime @default(now())
    - updatedAt: DateTime @updatedAt
    - Relation: mappingConfig MappingConfig @relation(fields: [mappingConfigId], references: [id], onDelete: Cascade)
    - Indexes: @@index([mappingConfigId]), @@index([mappingConfigId, order])
    - Table: @@map("transformation_rules")

    **LookupTable model:**
    - id: String @id @default(uuid())
    - name: String (lookup table name, e.g., "currency_codes")
    - description: String?
    - tenantId: String (FK to Tenant for multi-tenant isolation)
    - createdAt: DateTime @default(now())
    - updatedAt: DateTime @updatedAt
    - Relation: tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
    - Relation: entries LookupTableEntry[]
    - Indexes: @@index([tenantId]), @@unique([tenantId, name])
    - Table: @@map("lookup_tables")

    **LookupTableEntry model:**
    - id: String @id @default(uuid())
    - lookupTableId: String (FK to LookupTable)
    - fromValue: String
    - toValue: String
    - Relation: lookupTable LookupTable @relation(fields: [lookupTableId], references: [id], onDelete: Cascade)
    - Indexes: @@index([lookupTableId]), @@unique([lookupTableId, fromValue])
    - Table: @@map("lookup_table_entries")

    Also add reverse relations:
    - On MappingConfig: add `transformationRules TransformationRule[]`
    - On Tenant: add `lookupTables LookupTable[]`

    After editing schema, run: `npx prisma db push` to apply changes to the database.
    Then run: `npx prisma generate` to regenerate the Prisma client.
  </action>
  <verify>
    `npx prisma validate` succeeds.
    `npx prisma db push` applies without errors.
    `npx prisma generate` regenerates client.
  </verify>
  <done>TransformationRule and LookupTable models exist in schema with proper relations, indexes, and RLS-compatible tenantId fields. Prisma client is regenerated with new types.</done>
</task>

<task type="auto">
  <name>Task 2: Create API routes for transformation rules and lookup tables</name>
  <files>
    src/app/api/transformations/route.ts
    src/app/api/lookup-tables/route.ts
    src/app/api/lookup-tables/[id]/entries/route.ts
  </files>
  <action>
    **src/app/api/transformations/route.ts:**
    - GET: Accept query param `mappingConfigId`, return all TransformationRule records for that mapping ordered by `order` field ascending. Return 400 if mappingConfigId missing.
    - POST: Accept JSON body with { mappingConfigId, type, sourceFields, targetField, config, order, label? }. Validate `type` is one of the allowed TransformationType values. Create and return the new rule. Return 400 on validation failure.
    - Use prisma from `@/lib/prisma`. No RLS needed here since transformation rules are linked to MappingConfig (tenant-scoped through workspace chain).
    - Follow existing API pattern from src/app/api/parse-schema/route.ts.

    **src/app/api/lookup-tables/route.ts:**
    - GET: Accept query param `tenantId`, return all LookupTable records for that tenant. For now, use a hardcoded dev tenantId (same pattern as existing code - auth not yet built). Return tables with entry count.
    - POST: Accept JSON body with { name, description?, tenantId }. Validate name is non-empty. Create and return the new lookup table. Return 400 on validation failure, 409 if duplicate name for tenant.

    **src/app/api/lookup-tables/[id]/entries/route.ts:**
    - GET: Return all LookupTableEntry records for the lookup table identified by route param `id`, ordered by fromValue ascending.
    - POST: Accept JSON body with { fromValue, toValue } or array of { fromValue, toValue }. Create entries. Return 400 on validation failure, 409 on duplicate fromValue.
    - PUT: Accept JSON body with { id, fromValue, toValue }. Update an existing entry. Return 404 if not found.
    - DELETE: Accept query param `entryId`. Delete the entry. Return 404 if not found.

    All routes return JSON with consistent shape: { data: ... } on success, { error: string } on failure. Use try-catch for database errors.
  </action>
  <verify>
    `npm run build` compiles without TypeScript errors.
    Dev server starts with `npm run dev` and the following curl commands succeed:
    - POST /api/lookup-tables with { name: "test", tenantId: "[dev-tenant-id]" } returns 200
    - GET /api/lookup-tables?tenantId=[dev-tenant-id] returns the created table
  </verify>
  <done>API routes for transformation rules and lookup tables are functional. CRUD operations work for both models. Proper error handling with 400/404/409 status codes.</done>
</task>

</tasks>

<verification>
- Prisma schema validates and pushes without errors
- All new API routes compile and respond correctly
- TransformationRule correctly cascades from MappingConfig
- LookupTable correctly scoped by tenantId
- Lookup table entries enforce unique fromValue per table
</verification>

<success_criteria>
Database has TransformationRule, LookupTable, and LookupTableEntry tables. API routes provide full CRUD. Transformation rules are ordered. Lookup tables are tenant-scoped with unique name constraint.
</success_criteria>

<output>
After completion, create `.planning/phases/05-transformation-system/05-02-SUMMARY.md`
</output>
