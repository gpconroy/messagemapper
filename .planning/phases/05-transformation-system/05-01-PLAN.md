---
phase: 05-transformation-system
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/transformations/types.ts
  - src/transformations/registry.ts
  - src/transformations/builtins/format.ts
  - src/transformations/builtins/string.ts
  - src/transformations/builtins/conditional.ts
  - src/transformations/builtins/constant.ts
  - src/transformations/__tests__/builtins.test.ts
autonomous: true

must_haves:
  truths:
    - "Date values can be reformatted between any two date-fns format strings"
    - "Number values can be formatted with locale-specific currency and decimal styles"
    - "Multiple string values can be concatenated with a configurable separator"
    - "A single string value can be split into parts by delimiter or regex"
    - "Conditional logic maps input to different outputs based on comparison operators"
    - "A constant value can be assigned to a target field regardless of input"
  artifacts:
    - path: "src/transformations/types.ts"
      provides: "TransformationType enum, TransformFunction type, TransformationRule interface, per-type config interfaces"
      exports: ["TransformationType", "TransformFunction", "TransformationRule", "DateFormatConfig", "NumberFormatConfig", "SplitConfig", "ConcatenateConfig", "ConditionalConfig", "ConstantConfig"]
    - path: "src/transformations/registry.ts"
      provides: "Function registry mapping transformation types to handler functions"
      exports: ["transformRegistry", "executeTransform"]
    - path: "src/transformations/builtins/format.ts"
      provides: "Date and number formatting transforms"
      exports: ["formatDate", "formatNumber"]
    - path: "src/transformations/builtins/string.ts"
      provides: "Split and concatenate transforms"
      exports: ["splitString", "concatenateStrings"]
    - path: "src/transformations/builtins/conditional.ts"
      provides: "Conditional mapping transform"
      exports: ["applyConditional"]
    - path: "src/transformations/builtins/constant.ts"
      provides: "Constant value transform"
      exports: ["setConstant"]
    - path: "src/transformations/__tests__/builtins.test.ts"
      provides: "Test coverage for all 6 built-in transforms"
      min_lines: 100
  key_links:
    - from: "src/transformations/registry.ts"
      to: "src/transformations/builtins/*.ts"
      via: "Map registration of each transform function"
      pattern: "transformRegistry\\.set"
    - from: "src/transformations/types.ts"
      to: "src/transformations/builtins/*.ts"
      via: "Type imports for config interfaces"
      pattern: "import.*from.*types"
---

<objective>
Create the transformation type system, function registry, and all built-in transformation functions with full TDD coverage.

Purpose: Establish the core transformation engine that powers XFRM-01 (format conversion), XFRM-02 (concatenation), XFRM-03 (splitting), XFRM-04 (constants), and XFRM-05 (conditional logic). These pure functions form the composable building blocks of the transformation pipeline.

Output: 6 tested transform functions registered in a type-safe registry, with TypeScript interfaces for all transformation configuration.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-transformation-system/05-RESEARCH.md
</context>

<tasks>

<task type="tdd">
  <name>Built-in Transformation Functions</name>
  <files>
    src/transformations/types.ts
    src/transformations/registry.ts
    src/transformations/builtins/format.ts
    src/transformations/builtins/string.ts
    src/transformations/builtins/conditional.ts
    src/transformations/builtins/constant.ts
    src/transformations/__tests__/builtins.test.ts
  </files>
  <action>
    Install date-fns: `npm install date-fns`

    Follow TDD RED-GREEN-REFACTOR cycle for all 6 built-in transformation functions.

    **RED phase - Write failing tests first (src/transformations/__tests__/builtins.test.ts):**

    formatDate:
    - ('2026-02-12', { to: 'MM/dd/yyyy' }) -> '02/12/2026'
    - ('20260212', { from: 'yyyyMMdd', to: 'yyyy-MM-dd' }) -> '2026-02-12'
    - ('invalid', { to: 'yyyy' }) -> throws Error('Invalid date input')

    formatNumber:
    - (1234.56, { type: 'number', locale: 'en-US' }) -> '1,234.56'
    - (1234.56, { type: 'currency', currency: 'USD', locale: 'en-US' }) -> '$1,234.56'
    - ('not-a-number', { type: 'number' }) -> throws Error

    splitString:
    - ('John,Doe', { delimiter: ',' }) -> ['John', 'Doe']
    - ('John, Doe ; Jane', { delimiter: '[,;]', isRegex: true, trim: true }) -> ['John', 'Doe', 'Jane']
    - ('hello', { delimiter: ',' }) -> ['hello']

    concatenateStrings:
    - (['John', 'Doe'], { separator: ' ' }) -> 'John Doe'
    - (['  John ', ' Doe  '], { separator: ', ', trim: true }) -> 'John, Doe'
    - ('not-array', { separator: ' ' }) -> throws Error

    applyConditional:
    - ('ACTIVE', { operator: 'equals', value: 'ACTIVE', thenValue: true, elseValue: false }) -> true
    - ('INACTIVE', { operator: 'equals', value: 'ACTIVE', thenValue: true, elseValue: false }) -> false
    - ('Hello World', { operator: 'contains', value: 'World', thenValue: 'yes', elseValue: 'no' }) -> 'yes'
    - (100, { operator: 'greaterThan', value: 50, thenValue: 'high', elseValue: 'low' }) -> 'high'

    setConstant:
    - (null, { value: 'DEFAULT' }) -> 'DEFAULT'
    - ('anything', { value: 42 }) -> 42
    - (undefined, { value: null }) -> null

    Registry executeTransform:
    - ('format_date', '2026-02-12', { to: 'MM/dd/yyyy' }) -> '02/12/2026'
    - ('unknown_type', 'x', {}) -> throws Error('Unknown transformation type: unknown_type')

    **GREEN phase - Implement to pass tests:**

    **Types (src/transformations/types.ts):**
    Define TransformationType as union: 'format_date' | 'format_number' | 'split' | 'concatenate' | 'conditional' | 'lookup' | 'constant' | 'custom_js'

    Define TransformFunction signature: (input: unknown, config: Record&lt;string, unknown&gt;) => unknown | Promise&lt;unknown&gt;

    Define TransformationRule interface with: id (string), type (TransformationType), sourceFields (string[]), targetField (string), config (Record&lt;string, unknown&gt;), order (number)

    Define per-type config interfaces:
    - DateFormatConfig: { from?: string; to: string }
    - NumberFormatConfig: { type: 'number' | 'currency'; currency?: string; locale?: string; minimumFractionDigits?: number; maximumFractionDigits?: number }
    - SplitConfig: { delimiter: string; isRegex?: boolean; trim?: boolean }
    - ConcatenateConfig: { separator: string; trim?: boolean }
    - ConditionalConfig: { operator: 'equals' | 'notEquals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan'; value: unknown; thenValue: unknown; elseValue: unknown }
    - ConstantConfig: { value: unknown }

    **Registry (src/transformations/registry.ts):**
    Map&lt;TransformationType, TransformFunction&gt; with all 6 built-ins registered plus placeholders for 'lookup' and 'custom_js' that throw "not yet implemented"

    Export executeTransform(type, input, config) function that looks up and calls the registered function

    **Implementation details:**
    Use date-fns parse() and format() for date transforms (NOT moment.js - deprecated).
    Use native Intl.NumberFormat for number/currency formatting (no library needed, 97%+ support).
    Use String.prototype.split() with regex support for split operations.
    Validate regex patterns against a safe whitelist before creating RegExp to prevent ReDoS.
    All functions are pure - no side effects, no database access (lookup and custom_js deferred to later plans).
    Use strict type checking - throw descriptive errors on invalid input rather than returning undefined.
  </action>
  <verify>
    `npm test -- --testPathPattern="transformations"` passes with all test cases green.
    All 6 built-in functions exported and registered in registry.
    executeTransform dispatches correctly to all registered functions.
    Invalid types throw descriptive errors.
    date-fns is listed in package.json dependencies.
  </verify>
  <done>All built-in transformation functions pass their test cases. Registry pattern dispatches to correct functions. Types provide full TypeScript coverage for transformation configurations. No runtime errors on valid inputs.</done>
</task>

</tasks>

<verification>
- `npm test -- --testPathPattern="transformations"` passes with all test cases green
- All 6 built-in functions exported and registered in registry
- executeTransform dispatches correctly to all registered functions
- Invalid types throw descriptive errors
- date-fns is listed in package.json dependencies
</verification>

<success_criteria>
All built-in transformation functions pass their test cases. Registry pattern dispatches to correct functions. Types provide full TypeScript coverage for transformation configurations. No runtime errors on valid inputs.
</success_criteria>

<output>
After completion, create `.planning/phases/05-transformation-system/05-01-SUMMARY.md`
</output>
