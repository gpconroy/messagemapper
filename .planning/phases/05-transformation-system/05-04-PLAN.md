---
phase: 05-transformation-system
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - src/transformations/builtins/lookup.ts
  - src/transformations/pipeline.ts
  - src/transformations/validator.ts
  - src/transformations/index.ts
  - src/app/api/transformations/preview/route.ts
  - src/transformations/__tests__/pipeline.test.ts
autonomous: true

must_haves:
  truths:
    - "Transformation rules execute in order, each receiving prior results as context"
    - "Invalid transformation rules are rejected before execution with clear error messages"
    - "A dry-run mode previews transformation results without persisting changes"
    - "Lookup table resolution queries the database for tenant-scoped code translation"
    - "The pipeline handles errors gracefully, reporting which rule failed and why"
  artifacts:
    - path: "src/transformations/pipeline.ts"
      provides: "Transformation pipeline that chains rules in order with error collection"
      exports: ["applyTransformations", "TransformationResult"]
    - path: "src/transformations/validator.ts"
      provides: "Zod schemas for validating transformation rules before execution"
      exports: ["TransformationRuleSchema", "validateTransformationRules"]
    - path: "src/transformations/builtins/lookup.ts"
      provides: "Lookup table resolution transform using Prisma"
      exports: ["resolveLookup"]
    - path: "src/transformations/index.ts"
      provides: "Barrel export for transformation module"
      exports: ["applyTransformations", "executeTransform", "transformRegistry"]
    - path: "src/app/api/transformations/preview/route.ts"
      provides: "API endpoint for dry-run transformation preview"
      exports: ["POST"]
  key_links:
    - from: "src/transformations/pipeline.ts"
      to: "src/transformations/registry.ts"
      via: "executeTransform call for each rule"
      pattern: "executeTransform"
    - from: "src/transformations/pipeline.ts"
      to: "src/transformations/validator.ts"
      via: "Zod validation before pipeline execution"
      pattern: "validateTransformationRules|TransformationRuleSchema"
    - from: "src/transformations/builtins/lookup.ts"
      to: "prisma.lookupTableEntry"
      via: "Database query for lookup resolution"
      pattern: "prisma.*lookupTableEntry|findFirst"
    - from: "src/app/api/transformations/preview/route.ts"
      to: "src/transformations/pipeline.ts"
      via: "applyTransformations with dryRun flag"
      pattern: "applyTransformations.*dryRun"
---

<objective>
Wire all transformation components into a validated pipeline with dry-run preview capability, completing the backend transformation engine.

Purpose: Connects the built-in functions (Plan 01), database models (Plan 02), and sandbox (Plan 03) into a working pipeline that validates rules with Zod, executes them in order, handles errors, and provides a preview API. This is the orchestration layer that makes the transformation system usable.

Output: A working transformation pipeline that accepts sample data and rules, validates, executes in order, and returns results or errors. Plus a preview API endpoint for the UI to call.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-transformation-system/05-RESEARCH.md
@.planning/phases/05-transformation-system/05-01-SUMMARY.md
@.planning/phases/05-transformation-system/05-02-SUMMARY.md
@.planning/phases/05-transformation-system/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lookup transform, Zod validator, and transformation pipeline</name>
  <files>
    src/transformations/builtins/lookup.ts
    src/transformations/validator.ts
    src/transformations/pipeline.ts
    src/transformations/index.ts
    src/transformations/__tests__/pipeline.test.ts
  </files>
  <action>
    **src/transformations/builtins/lookup.ts:**
    Implement resolveLookup function that:
    - Takes input (unknown), config ({ tableName: string, defaultValue?: unknown }), and context ({ prisma: PrismaClient })
    - Queries prisma.lookupTableEntry.findFirst where lookupTable.name matches tableName AND fromValue matches String(input)
    - Returns entry.toValue if found, config.defaultValue if provided, or throws Error('No lookup entry found for X in table Y')
    - Register this function in the transform registry by updating registry.ts to import and register 'lookup' -> resolveLookup

    Also update registry.ts to register the 'custom_js' function by importing executeCustomJS from custom/sandbox.ts and wrapping it to match TransformFunction signature: (input, config) => executeCustomJS(config.code as string, input, { timeout: config.timeout as number || 5000, memoryLimit: config.memoryLimit as number || 128 })

    **src/transformations/validator.ts:**
    Define Zod schemas:
    - TransformationRuleSchema: z.object with id, type (z.enum of all 8 types), sourceFields (z.array of z.string min 1), targetField (z.string), config (z.record of z.unknown), order (z.number().int().min(0))
    - Per-type config schemas: DateFormatConfigSchema, NumberFormatConfigSchema, SplitConfigSchema, ConcatenateConfigSchema, ConditionalConfigSchema, ConstantConfigSchema, LookupConfigSchema, CustomJSConfigSchema
    - validateTransformationRules(rules: unknown[]): { valid: boolean, rules?: TransformationRule[], errors?: string[] } - validates array of rules, then validates each rule's config against its type-specific schema
    - Export all schemas

    **src/transformations/pipeline.ts:**
    Define TransformationResult: { success: boolean; result?: Record&lt;string, unknown&gt;; errors?: string[]; ruleResults?: Array&lt;{ ruleId: string; type: string; success: boolean; output?: unknown; error?: string }&gt; }

    Implement applyTransformations(data: Record&lt;string, unknown&gt;, rules: unknown[], context?: { prisma?: PrismaClient }, options?: { dryRun?: boolean }):
    1. Validate rules using validateTransformationRules. Return early with errors if invalid.
    2. Sort valid rules by order field ascending.
    3. Clone data object (spread into new object).
    4. For each rule: extract input from result using sourceFields (single field = direct value, multiple fields = array of values). Call executeTransform. If dryRun, record result but don't mutate. If not dryRun, set result[targetField] = transformed value.
    5. Collect per-rule results in ruleResults array.
    6. On error in any rule: record error in ruleResults, continue to next rule (collect all errors, don't stop at first).
    7. Return { success: allRulesSucceeded, result, errors: collectedErrors, ruleResults }.

    **src/transformations/index.ts:**
    Barrel export: re-export types, registry, pipeline, validator public APIs.

    **src/transformations/__tests__/pipeline.test.ts:**
    Test the pipeline with a multi-rule scenario:
    - 3 rules chained: formatDate -> concatenate -> conditional
    - Test validation rejection of invalid rules
    - Test dryRun mode (original data unchanged)
    - Test error collection when one rule fails (other rules still execute)
    - Test rule ordering (out-of-order input gets sorted)
    Mock Prisma for lookup tests (don't need real DB in unit tests).
  </action>
  <verify>
    `npm test -- --testPathPattern="pipeline"` passes.
    `npm run build` succeeds without TypeScript errors.
    All 8 transformation types are registered in the registry (format_date, format_number, split, concatenate, conditional, lookup, constant, custom_js).
  </verify>
  <done>Pipeline validates, sorts, and executes transformation rules in order. Error collection works per-rule. DryRun mode works. Lookup transform queries database. Custom JS dispatches to sandbox. All 8 types registered.</done>
</task>

<task type="auto">
  <name>Task 2: Create transformation preview API endpoint</name>
  <files>src/app/api/transformations/preview/route.ts</files>
  <action>
    Create POST /api/transformations/preview endpoint that:
    - Accepts JSON body: { rules: TransformationRule[], sampleData: Record&lt;string, unknown&gt; }
    - Validates request body (rules array non-empty, sampleData is object)
    - Calls applyTransformations(sampleData, rules, { prisma }, { dryRun: true })
    - Returns { data: { result, ruleResults, errors } } on success
    - Returns { error: string } with 400 on validation failure
    - Returns { error: string } with 500 on unexpected errors
    - Import prisma from @/lib/prisma for lookup transform support
    - Follow same API response shape pattern as existing routes (src/app/api/parse-schema/route.ts)
  </action>
  <verify>
    `npm run build` succeeds.
    Dev server running, curl POST /api/transformations/preview with:
    ```json
    {
      "rules": [
        { "id": "r1", "type": "constant", "sourceFields": ["_"], "targetField": "status", "config": { "value": "ACTIVE" }, "order": 0 }
      ],
      "sampleData": { "name": "test" }
    }
    ```
    Returns 200 with result containing status: "ACTIVE".
  </verify>
  <done>Preview API endpoint accepts sample data and rules, runs transformation pipeline in dry-run mode, returns per-rule results. Error cases return proper HTTP status codes.</done>
</task>

</tasks>

<verification>
- All transformation types (8) registered and callable via executeTransform
- Pipeline validates, sorts by order, executes, collects errors
- Preview API endpoint functional
- Lookup transform works with Prisma (mocked in tests, real in API)
- Custom JS dispatches to sandbox correctly
- `npm test` and `npm run build` both pass
</verification>

<success_criteria>
Complete backend transformation engine functional: types validated with Zod, 8 transform types registered, pipeline executes in order with error collection, preview API returns dry-run results. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/05-transformation-system/05-04-SUMMARY.md`
</output>
