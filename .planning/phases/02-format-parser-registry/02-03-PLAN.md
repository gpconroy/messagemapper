---
phase: 02-format-parser-registry
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/parsers/index.ts
  - src/app/api/parse-schema/route.ts
  - src/lib/parsers/__tests__/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "User can upload an XSD file via API and receive parsed FieldNode tree"
    - "User can upload an XML sample via API and receive inferred FieldNode tree"
    - "User can upload a JSON schema via API and receive parsed FieldNode tree"
    - "User can upload a JSON sample via API and receive inferred FieldNode tree"
    - "User sees validation errors when uploading malformed files"
    - "Format is auto-detected from file extension and content"
    - "File size limit prevents upload of files larger than 5MB"
  artifacts:
    - path: "src/lib/parsers/index.ts"
      provides: "Parser registration and barrel export"
      exports: ["parserRegistry", "JsonSchemaParser", "JsonSampleParser", "XmlSampleParser", "XsdParser"]
    - path: "src/app/api/parse-schema/route.ts"
      provides: "POST endpoint accepting file uploads and returning parsed FieldNode[]"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/parse-schema/route.ts"
      to: "src/lib/parsers/index.ts"
      via: "imports parserRegistry, calls parseFile()"
      pattern: "parserRegistry\\.parseFile"
    - from: "src/lib/parsers/index.ts"
      to: "src/lib/parsers/json-schema-parser.ts"
      via: "registers parser"
      pattern: "register.*json-schema"
    - from: "src/lib/parsers/index.ts"
      to: "src/lib/parsers/xml-sample-parser.ts"
      via: "registers parser"
      pattern: "register.*xml-sample"
    - from: "src/lib/parsers/index.ts"
      to: "src/lib/parsers/xsd-parser.ts"
      via: "registers parser"
      pattern: "register.*xsd"
---

<objective>
Wire all four parsers into the registry, create the Next.js API route for file upload and parsing, and run integration tests proving all formats produce consistent FieldNode output.

Purpose: This plan delivers the user-facing entry point — the API route that accepts file uploads and returns parsed field trees. It also proves all parsers work together through the registry with consistent output.

Output: Working /api/parse-schema POST endpoint, parser barrel exports, and integration tests covering all 4 formats end-to-end.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-format-parser-registry/02-RESEARCH.md
@.planning/phases/02-format-parser-registry/02-01-SUMMARY.md
@.planning/phases/02-format-parser-registry/02-02-SUMMARY.md
@src/types/parser-types.ts
@src/lib/parsers/registry.ts
@src/lib/parsers/json-schema-parser.ts
@src/lib/parsers/json-sample-parser.ts
@src/lib/parsers/xml-sample-parser.ts
@src/lib/parsers/xsd-parser.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create parser barrel export with registration and API route for file upload</name>
  <files>
    src/lib/parsers/index.ts
    src/app/api/parse-schema/route.ts
  </files>
  <action>
    **Step 1: Create parser barrel export and registration in `src/lib/parsers/index.ts`.**

    This file is the single import point for all parser functionality:

    ```typescript
    // Re-export types
    export type { FieldNode, ParserType, BaseParser, ParseOptions, ValidationResult, ParserResult } from '@/types/parser-types';

    // Re-export utilities
    export { normalizeType, generatePath, generateId } from './normalize';

    // Re-export registry
    export { ParserRegistry, parserRegistry } from './registry';

    // Import and register all parsers
    import { parserRegistry } from './registry';
    import { JsonSchemaParser } from './json-schema-parser';
    import { JsonSampleParser } from './json-sample-parser';
    import { XmlSampleParser } from './xml-sample-parser';
    import { XsdParser } from './xsd-parser';

    // Register all built-in parsers
    parserRegistry.register('json-schema', new JsonSchemaParser());
    parserRegistry.register('json-sample', new JsonSampleParser());
    parserRegistry.register('xml-sample', new XmlSampleParser());
    parserRegistry.register('xsd', new XsdParser());

    // Re-export parser classes for direct use if needed
    export { JsonSchemaParser, JsonSampleParser, XmlSampleParser, XsdParser };
    ```

    **Step 2: Create API route in `src/app/api/parse-schema/route.ts`.**

    POST endpoint that accepts multipart form data with a file upload:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { parserRegistry } from '@/lib/parsers';
    import type { ParserResult } from '@/types/parser-types';
    ```

    Implementation:

    1. **Extract file from FormData:**
       ```typescript
       const formData = await request.formData();
       const file = formData.get('file') as File | null;
       ```

    2. **Validate file exists:**
       If no file → return 400 `{ error: 'No file provided' }`

    3. **Validate file size (5MB limit):**
       ```typescript
       const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
       if (file.size > MAX_FILE_SIZE) {
         return NextResponse.json(
           { error: 'File too large. Maximum size is 5MB.' },
           { status: 400 }
         );
       }
       ```

    4. **Read file content:**
       ```typescript
       const content = await file.text();
       ```

    5. **Optional format override:**
       Allow caller to specify format type explicitly via form field:
       ```typescript
       const formatOverride = formData.get('format') as string | null;
       ```

    6. **Parse using registry:**
       If formatOverride provided, use it directly. Otherwise let registry auto-detect from filename + content:
       ```typescript
       let result: ParserResult;
       try {
         if (formatOverride) {
           const parser = parserRegistry.getParser(formatOverride as ParserType);
           const validation = await parser.validate(content);
           if (!validation.valid) {
             result = { success: false, fieldNodes: [], errors: validation.errors, parserType: formatOverride as ParserType };
           } else {
             const fieldNodes = await parser.parse(content);
             result = { success: true, fieldNodes, errors: [], parserType: formatOverride as ParserType };
           }
         } else {
           result = await parserRegistry.parseFile(content, file.name);
         }
       } catch (error) {
         return NextResponse.json(
           { error: error instanceof Error ? error.message : 'Parse failed' },
           { status: 400 }
         );
       }
       ```

    7. **Return result:**
       - Success: 200 with `{ success: true, fieldNodes: [...], parserType: '...' }`
       - Validation errors: 200 with `{ success: false, fieldNodes: [], errors: [...], parserType: '...' }`
       - Unexpected errors: 500 with `{ error: 'Internal server error' }`

    8. **Error handling:** Wrap entire handler in try/catch. Log errors with console.error. Return generic 500 for unexpected failures (don't leak internal details).

    The route should use the standard ApiResponse/ApiError types from src/types/index.ts for the error response shape, but the success response uses ParserResult directly since it has its own structure.
  </action>
  <verify>
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Run `npm run build` — build succeeds (confirms API route compiles).
    Verify `src/lib/parsers/index.ts` registers all 4 parsers.
    Verify `src/app/api/parse-schema/route.ts` exports POST function.
  </verify>
  <done>
    Parser barrel export registers all 4 parsers into the singleton registry. API route accepts file uploads via POST /api/parse-schema, auto-detects format, validates input, and returns FieldNode[] or error messages. File size limited to 5MB. Format can be overridden via form field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests verifying all parsers produce consistent output through the registry</name>
  <files>
    src/lib/parsers/__tests__/integration.test.ts
  </files>
  <action>
    **Step 1: Create integration test file `src/lib/parsers/__tests__/integration.test.ts`.**

    These tests verify end-to-end behavior through the registry, not individual parsers. They use realistic sample inputs and verify:
    - All parsers register correctly
    - Format detection works
    - FieldNode structure is consistent across formats
    - Validation errors surface correctly

    **Test group 1: Registry integration**

    1. **All 4 parsers registered:** Import from `@/lib/parsers` and verify `parserRegistry.hasParser()` returns true for 'json-schema', 'json-sample', 'xml-sample', 'xsd'.

    2. **Format detection round-trip for JSON Schema:**
       Call `parserRegistry.parseFile(jsonSchemaContent, 'payment.json')` with content that has `$schema` → returns success with parserType='json-schema'.

    3. **Format detection round-trip for JSON sample:**
       Call `parserRegistry.parseFile(jsonSampleContent, 'payment.json')` with content that does NOT have `$schema` → returns success with parserType='json-sample'.

    4. **Format detection for XML:**
       Call `parserRegistry.parseFile(xmlContent, 'payment.xml')` → parserType='xml-sample'.

    5. **Format detection for XSD:**
       Call `parserRegistry.parseFile(xsdContent, 'payment.xsd')` → parserType='xsd'.

    **Test group 2: FieldNode structure consistency**

    Create equivalent structures in all 4 formats representing the same data:

    A "Payment" with fields: id (integer), amount (number), currency (string), sender (object with name and account), items (array of objects with description and quantity).

    Define these as test fixtures:

    - `paymentJsonSchema`: JSON Schema defining Payment type
    - `paymentJsonSample`: Sample JSON payment document
    - `paymentXmlSample`: Sample XML payment document
    - `paymentXsd`: XSD schema defining Payment type

    For each format, parse and verify:

    6. **Root structure:** All parsers return FieldNode[] with expected root structure.

    7. **Field types match:** For equivalent fields across formats, the normalized `type` matches. id→integer, amount→number, currency→string, sender→object, items→array.

    8. **Nested fields exist:** sender.name and sender.account exist in all parser outputs.

    9. **Array children:** items[].description and items[].quantity exist in all parser outputs.

    10. **Every node has required fields:** Every FieldNode in every output has all 6 required properties: id, name, path, type, required, children. Use a recursive helper to check.

    **Test group 3: Validation error handling**

    11. **Malformed JSON through registry:**
        Call `parserRegistry.parseFile('not json{', 'bad.json')` → result.success=false, result.errors is non-empty.

    12. **Malformed XML through registry:**
        Call `parserRegistry.parseFile('<unclosed', 'bad.xml')` → result.success=false, result.errors is non-empty.

    13. **Malformed XSD through registry:**
        Call `parserRegistry.parseFile('<root>not xsd</root>', 'bad.xsd')` → result.success=false, result.errors is non-empty.

    14. **Unsupported format:**
        Call `parserRegistry.parseFile('data', 'file.csv')` → throws error (unsupported format).

    **Test group 4: Edge cases**

    15. **Empty JSON object:** `{}` → valid parse, empty or minimal FieldNode[].

    16. **Large nested structure:** 10+ levels deep → parses without timeout or stack overflow.

    **Step 2: Run ALL tests.**
    ```bash
    npx jest
    ```
    All tests across all files must pass.

    **Step 3: Verify build.**
    ```bash
    npm run build
    ```
    Next.js build must succeed (confirms API route + parser imports work in production build).
  </action>
  <verify>
    Run `npx jest` — ALL tests pass (unit + integration).
    Run `npm run build` — build succeeds with zero errors.
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Verify integration tests cover all 4 formats with consistent FieldNode output.
    Verify validation error tests cover malformed input for JSON, XML, and XSD.
  </verify>
  <done>
    Integration tests prove all 4 parsers register correctly, auto-detect formats, produce consistent FieldNode structures for equivalent data, and surface validation errors for malformed input. Next.js build succeeds confirming API route compiles. Phase 2 success criteria fully satisfied: JSON Schema, JSON sample, XML sample, and XSD all produce normalized FieldNode output through the parser registry.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify ALL Phase 2 success criteria:

1. **PARS-01:** "User can upload an XSD schema file and see its field structure parsed into a navigable tree" — XSD parser tested, API route accepts .xsd uploads
2. **PARS-02:** "User can upload a sample XML message and have its structure inferred automatically" — XML sample parser tested, API route accepts .xml uploads
3. **PARS-03:** "User can upload a JSON schema or sample JSON and see its field structure parsed" — Both JSON parsers tested, API route auto-detects schema vs sample
4. **PARS-08:** "User sees validation errors when uploading a malformed schema or sample" — All parsers validate before parsing, errors returned in response
5. **SC-5:** "All parsers produce the same normalized FieldNode structure" — Integration tests verify structural consistency across all 4 formats

Run:
```bash
npx jest                # All unit + integration tests pass
npm run build           # Production build succeeds
npx tsc --noEmit        # Zero TypeScript errors
```
</verification>

<success_criteria>
- All 4 parsers registered in singleton registry via barrel export
- API route POST /api/parse-schema accepts file uploads and returns FieldNode[] or errors
- Format auto-detected from filename + content analysis
- File size limited to 5MB
- Integration tests prove consistent FieldNode output across all formats
- Validation errors returned for malformed input (not crashes)
- Next.js build succeeds
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-format-parser-registry/02-03-SUMMARY.md`
</output>
