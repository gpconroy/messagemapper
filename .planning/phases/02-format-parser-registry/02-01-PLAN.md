---
phase: 02-format-parser-registry
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/types/parser-types.ts
  - src/lib/parsers/registry.ts
  - src/lib/parsers/normalize.ts
  - src/lib/parsers/json-schema-parser.ts
  - src/lib/parsers/json-sample-parser.ts
  - src/lib/parsers/__tests__/json-schema-parser.test.ts
  - src/lib/parsers/__tests__/json-sample-parser.test.ts
  - src/lib/parsers/__tests__/registry.test.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "All parsers produce the same FieldNode structure with id, name, path, type, required, and children"
    - "JSON Schema with $ref pointers is fully dereferenced before field extraction"
    - "JSON sample data has its structure inferred with correct types (string, number, integer, boolean, object, array)"
    - "Parser registry returns correct parser for a given format type"
    - "Malformed JSON input produces validation errors, not crashes"
  artifacts:
    - path: "src/types/parser-types.ts"
      provides: "FieldNode, ParserType, BaseParser, ParseOptions, ValidationResult, ParserResult types"
      contains: "interface FieldNode"
    - path: "src/lib/parsers/registry.ts"
      provides: "ParserRegistry class with register, getParser, detectFormat"
      exports: ["ParserRegistry", "parserRegistry"]
    - path: "src/lib/parsers/normalize.ts"
      provides: "Type normalization and path generation utilities"
      exports: ["normalizeType", "generatePath", "generateId"]
    - path: "src/lib/parsers/json-schema-parser.ts"
      provides: "JSON Schema parser with $ref dereferencing via json-schema-ref-parser"
      exports: ["JsonSchemaParser"]
    - path: "src/lib/parsers/json-sample-parser.ts"
      provides: "JSON sample inference parser"
      exports: ["JsonSampleParser"]
  key_links:
    - from: "src/lib/parsers/json-schema-parser.ts"
      to: "src/types/parser-types.ts"
      via: "implements BaseParser, returns FieldNode[]"
      pattern: "implements BaseParser"
    - from: "src/lib/parsers/json-sample-parser.ts"
      to: "src/types/parser-types.ts"
      via: "implements BaseParser, returns FieldNode[]"
      pattern: "implements BaseParser"
    - from: "src/lib/parsers/registry.ts"
      to: "src/lib/parsers/json-schema-parser.ts"
      via: "registers parser instance"
      pattern: "register.*json-schema"
---

<objective>
Define the normalized FieldNode type system, parser registry infrastructure, and implement JSON Schema + JSON sample parsers with full test coverage.

Purpose: Establish the type foundation and registry pattern that all format parsers must conform to, then implement the two JSON-based parsers as the first concrete implementations. This is TDD — tests define expected behavior before implementation.

Output: Tested FieldNode types, working ParserRegistry, JsonSchemaParser (with $ref resolution), JsonSampleParser (with type inference), and shared normalization utilities.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-format-parser-registry/02-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@src/types/index.ts
@prisma/schema.prisma
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies, define FieldNode types, parser interfaces, registry, and normalization utilities</name>
  <files>
    package.json
    src/types/parser-types.ts
    src/lib/parsers/registry.ts
    src/lib/parsers/normalize.ts
    src/lib/parsers/__tests__/registry.test.ts
    jest.config.ts
    tsconfig.json
  </files>
  <action>
    **Step 1: Install dependencies.**
    ```bash
    npm install ajv ajv-formats fast-xml-parser @apidevtools/json-schema-ref-parser
    npm install -D jest @types/jest ts-jest @jest/globals
    ```

    **Step 2: Configure Jest for TypeScript.**
    Create `jest.config.ts` at project root:
    - preset: 'ts-jest'
    - testEnvironment: 'node'
    - roots: ['<rootDir>/src']
    - moduleNameMapper: map '@/' to 'src/'
    - testMatch: ['**/__tests__/**/*.test.ts']
    Add "test" script to package.json: `"test": "jest"`
    Update tsconfig.json: add "jest" to types array under compilerOptions if not present. Ensure esModuleInterop is true (needed for json-schema-ref-parser default import).

    **Step 3: Define parser types in `src/types/parser-types.ts`.**
    Define these types (export all):

    ```typescript
    /** Normalized field node — the universal output of all parsers */
    export interface FieldNode {
      id: string;          // Stable ID derived from path (for React keys)
      name: string;        // Display name of this field
      path: string;        // Dot-notation path: "root.parent.child" or "root.items[]"
      type: FieldType;     // Normalized type
      required: boolean;   // Whether field is required in schema (false for samples)
      children: FieldNode[];  // Nested fields
    }

    /** Canonical type set — all parsers normalize to these */
    export type FieldType = 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array' | 'date' | 'null' | 'any';

    /** Supported parser format types */
    export type ParserType = 'json-schema' | 'json-sample' | 'xml-sample' | 'xsd';

    /** Options passed to parsers */
    export interface ParseOptions {
      strict?: boolean;
      maxDepth?: number;  // Prevent infinite recursion (default 50)
    }

    /** Validation result before parsing */
    export interface ValidationResult {
      valid: boolean;
      errors: string[];
    }

    /** Full parse result including validation */
    export interface ParserResult {
      success: boolean;
      fieldNodes: FieldNode[];
      errors: string[];
      parserType: ParserType;
    }

    /** Interface all parsers must implement */
    export interface BaseParser {
      readonly format: ParserType;
      parse(content: string, options?: ParseOptions): Promise<FieldNode[]>;
      validate(content: string): Promise<ValidationResult>;
    }
    ```

    Do NOT add FieldNode to `src/types/index.ts` — keep parser types separate. The index.ts is for application-level types only (per 01-01 decision).

    **Step 4: Create normalization utilities in `src/lib/parsers/normalize.ts`.**
    These are shared by all parsers:

    - `normalizeType(rawType: string | string[] | undefined): FieldType` — Maps schema-specific types to canonical FieldType. Handle: JSON Schema types (string, number, integer, boolean, null, object, array), XSD types (xs:string → string, xs:int/xs:integer/xs:long/xs:short → integer, xs:decimal/xs:float/xs:double → number, xs:boolean → boolean, xs:date/xs:dateTime → date), array types as 'array', null/undefined as 'any'. If input is array (JSON Schema allows `["string", "null"]`), pick first non-null type.

    - `generatePath(parentPath: string, name: string, isArrayItem?: boolean): string` — Produces canonical dot-notation paths: `parent.child`, `parent.items[]` for arrays. Root level uses just the name (no prefix).

    - `generateId(path: string): string` — Converts path to stable ID for React keys. Replace dots with dashes, brackets with '-array'. Example: `root.items[].name` → `root-items-array-name`.

    **Step 5: Create ParserRegistry in `src/lib/parsers/registry.ts`.**

    ```typescript
    export class ParserRegistry {
      private parsers = new Map<ParserType, BaseParser>();

      register(type: ParserType, parser: BaseParser): void;
      getParser(type: ParserType): BaseParser;  // throws if not found
      hasParser(type: ParserType): boolean;
      detectFormat(content: string, filename: string): ParserType;  // throws on unknown
      async parseFile(content: string, filename: string, options?: ParseOptions): Promise<ParserResult>;
    }
    ```

    `detectFormat` logic:
    - filename ends with '.xsd' → 'xsd'
    - filename ends with '.xml' → 'xml-sample'
    - filename ends with '.json' → try JSON.parse; if has `$schema` or (`type` and `properties` at root) → 'json-schema'; else → 'json-sample'
    - otherwise throw Error('Unsupported file format: {ext}')

    `parseFile` should:
    1. Detect format
    2. Get parser
    3. Call validate() first — if invalid, return { success: false, fieldNodes: [], errors, parserType }
    4. Call parse() — wrap in try/catch, return errors on failure
    5. Return { success: true, fieldNodes, errors: [], parserType }

    Export singleton: `export const parserRegistry = new ParserRegistry();`
    Do NOT register parsers in registry.ts — parsers register themselves or registration happens in a setup file (Plan 02-03 will wire this).

    **Step 6: Write registry tests in `src/lib/parsers/__tests__/registry.test.ts`.**
    Test:
    - register() and getParser() round-trip
    - getParser() throws for unregistered type
    - hasParser() returns true/false correctly
    - detectFormat() returns 'json-schema' for content with $schema property
    - detectFormat() returns 'json-sample' for plain JSON object
    - detectFormat() returns 'xml-sample' for .xml filename
    - detectFormat() returns 'xsd' for .xsd filename
    - detectFormat() throws for unknown extension
    Use a mock parser implementing BaseParser for register/get tests.
  </action>
  <verify>
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Run `npx jest --testPathPattern=registry` — all registry tests pass.
    Confirm src/types/parser-types.ts exports FieldNode, BaseParser, ParserType, etc.
    Confirm src/lib/parsers/normalize.ts exports normalizeType, generatePath, generateId.
  </verify>
  <done>
    FieldNode type and BaseParser interface defined. ParserRegistry class works with register/get/detect. Normalization utilities handle type mapping from JSON Schema and XSD vocabularies. All registry tests pass. Jest is configured for the project.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JsonSchemaParser and JsonSampleParser with TDD</name>
  <files>
    src/lib/parsers/json-schema-parser.ts
    src/lib/parsers/json-sample-parser.ts
    src/lib/parsers/__tests__/json-schema-parser.test.ts
    src/lib/parsers/__tests__/json-sample-parser.test.ts
  </files>
  <action>
    **TDD approach: Write tests first (RED), then implement (GREEN).**

    **Step 1: Write JsonSchemaParser tests in `src/lib/parsers/__tests__/json-schema-parser.test.ts`.**

    Test cases (write ALL before implementing):

    1. **Simple flat object:** Schema with `{ type: "object", properties: { name: { type: "string" }, age: { type: "integer" } }, required: ["name"] }` → produces 2 FieldNodes, name.required=true, age.required=false, correct paths and types.

    2. **Nested object:** Schema with nested `address: { type: "object", properties: { street, city } }` → produces FieldNode with children for street and city, paths like "address.street".

    3. **Array field:** Schema with `items: { type: "array", items: { type: "object", properties: { id, name } } }` → array node with children accessed via `items[]` path.

    4. **$ref resolution:** Schema with `$ref: "#/$defs/Address"` and a `$defs.Address` definition → correctly dereferences and produces full structure (use @apidevtools/json-schema-ref-parser).

    5. **Type normalization:** Schema fields with types "string", "number", "integer", "boolean", ["string", "null"] → produce correct FieldType values.

    6. **Validation — valid schema:** Call validate() with valid JSON Schema → `{ valid: true, errors: [] }`.

    7. **Validation — invalid JSON:** Call validate() with malformed JSON string → `{ valid: false, errors: [...] }` with meaningful error message.

    8. **Validation — not a schema:** Call validate() with valid JSON that is clearly not a schema (e.g., `"hello"`) → `{ valid: false, errors: [...] }`.

    9. **Empty properties:** Schema with `{ type: "object", properties: {} }` → returns empty array.

    10. **maxDepth option:** Deeply nested schema (10+ levels) with maxDepth=3 → stops at depth 3, no infinite recursion.

    **Step 2: Implement JsonSchemaParser in `src/lib/parsers/json-schema-parser.ts`.**

    - `implements BaseParser` with `readonly format: ParserType = 'json-schema'`
    - `validate(content: string)`: Try JSON.parse. Check root has `type: "object"` or `properties` or `$schema`. Return errors if not.
    - `parse(content: string, options?)`:
      1. JSON.parse the content
      2. Dereference $ref using `$RefParser.dereference(schema, { dereference: { circular: 'ignore' } })`
      3. Recursively walk `properties`, building FieldNode[] using normalizeType() and generatePath() from normalize.ts
      4. Handle `required` array at each object level
      5. Handle arrays: if property.type === 'array' and property.items exists, recurse into items
      6. Respect options.maxDepth (default 50) to prevent infinite recursion on circular schemas
    - Use `generateId()` from normalize.ts for all IDs

    **Step 3: Run JsonSchemaParser tests — all must pass (GREEN).**

    **Step 4: Write JsonSampleParser tests in `src/lib/parsers/__tests__/json-sample-parser.test.ts`.**

    Test cases:

    1. **Flat object:** `{ "name": "John", "age": 30, "active": true }` → 3 FieldNodes with types string, integer, boolean. All required=false (samples can't determine required).

    2. **Nested object:** `{ "user": { "name": "John", "address": { "city": "Dublin" } } }` → nested FieldNodes with correct paths "user.name", "user.address.city".

    3. **Array of objects:** `{ "items": [{ "id": 1, "name": "Widget" }] }` → array node with path "items", child with path "items[].id" and "items[].name". Type inference from first element.

    4. **Type inference:** `{ "str": "hello", "num": 3.14, "int": 42, "bool": false, "nil": null }` → types: string, number, integer, boolean, null.

    5. **Date detection:** `{ "created": "2024-01-15T10:30:00Z" }` → type "date" (detects ISO date strings).

    6. **Empty object:** `{}` → empty children array.

    7. **Empty array:** `{ "items": [] }` → array node with empty children (or single 'any' child).

    8. **Validation — valid JSON:** validate() with valid JSON → `{ valid: true, errors: [] }`.

    9. **Validation — invalid JSON:** validate() with malformed string → `{ valid: false, errors: [...] }`.

    10. **Deeply nested:** 5 levels deep → correct paths at each level.

    **Step 5: Implement JsonSampleParser in `src/lib/parsers/json-sample-parser.ts`.**

    - `implements BaseParser` with `readonly format: ParserType = 'json-sample'`
    - `validate(content: string)`: Try JSON.parse. Return errors if fails.
    - `parse(content: string, options?)`:
      1. JSON.parse the content
      2. Wrap in root node if top-level is object
      3. Recursively infer structure: for objects → create FieldNode per key with children; for arrays → infer from first element; for primitives → infer type using normalizeType
      4. All fields have required=false (sample data cannot determine required fields)
      5. Detect ISO date strings ("2024-01-15" or "2024-01-15T10:30:00Z" patterns) and map to 'date' type
      6. Respect options.maxDepth

    **Step 6: Run all tests — JsonSchemaParser + JsonSampleParser + registry all pass (GREEN).**

    **Step 7: Refactor if needed (REFACTOR).** Extract any duplicated logic between parsers into normalize.ts.
  </action>
  <verify>
    Run `npx jest` — ALL tests pass (registry + json-schema-parser + json-sample-parser).
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Verify FieldNode output manually: `console.log(JSON.stringify(result, null, 2))` for a sample JSON schema — should show id, name, path, type, required, children at every level.
  </verify>
  <done>
    JsonSchemaParser correctly parses JSON Schema with $ref resolution, nested objects, arrays, and type normalization. JsonSampleParser infers structure from sample JSON with type detection including dates. Both produce FieldNode[] conforming to the shared interface. Both validate() methods catch malformed input and return user-facing error messages. All tests pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npx jest` shows all tests passing
3. FieldNode type exported from src/types/parser-types.ts
4. ParserRegistry exported from src/lib/parsers/registry.ts
5. JsonSchemaParser handles $ref dereferencing correctly
6. JsonSampleParser infers types including date detection
7. Both parsers use shared normalizeType() and generatePath() from normalize.ts
8. Stable IDs generated from paths (no random UUIDs)
</verification>

<success_criteria>
- All parser types defined with strict TypeScript
- ParserRegistry correctly routes format types to parsers
- JsonSchemaParser produces correct FieldNode[] for schemas with nested objects, arrays, $ref, and required fields
- JsonSampleParser produces correct FieldNode[] for sample JSON with type inference
- Both parsers return validation errors for malformed input
- All tests pass
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-format-parser-registry/02-01-SUMMARY.md`
</output>
