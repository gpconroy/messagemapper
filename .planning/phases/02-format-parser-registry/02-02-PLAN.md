---
phase: 02-format-parser-registry
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/parsers/xml-sample-parser.ts
  - src/lib/parsers/xsd-parser.ts
  - src/lib/parsers/__tests__/xml-sample-parser.test.ts
  - src/lib/parsers/__tests__/xsd-parser.test.ts
autonomous: true

must_haves:
  truths:
    - "XML sample data is parsed into the same FieldNode structure as JSON parsers"
    - "XML attributes are represented as child FieldNodes with '@' path prefix"
    - "Repeated XML elements are detected as arrays"
    - "XSD schema files produce FieldNode trees from xs:element and xs:complexType definitions"
    - "XSD type attributes (xs:string, xs:int, xs:decimal, xs:date) are normalized to canonical FieldType"
    - "Malformed XML or XSD produces validation errors, not crashes"
  artifacts:
    - path: "src/lib/parsers/xml-sample-parser.ts"
      provides: "XML sample parser using fast-xml-parser"
      exports: ["XmlSampleParser"]
    - path: "src/lib/parsers/xsd-parser.ts"
      provides: "XSD schema parser that parses XSD as XML and extracts field structure"
      exports: ["XsdParser"]
  key_links:
    - from: "src/lib/parsers/xml-sample-parser.ts"
      to: "src/types/parser-types.ts"
      via: "implements BaseParser, returns FieldNode[]"
      pattern: "implements BaseParser"
    - from: "src/lib/parsers/xsd-parser.ts"
      to: "src/types/parser-types.ts"
      via: "implements BaseParser, returns FieldNode[]"
      pattern: "implements BaseParser"
    - from: "src/lib/parsers/xsd-parser.ts"
      to: "src/lib/parsers/normalize.ts"
      via: "uses normalizeType to map xs:string etc. to FieldType"
      pattern: "normalizeType"
---

<objective>
Implement XML sample parser and XSD schema parser, completing the four format parsers needed for Phase 2.

Purpose: XML and XSD are the most complex parsing targets in this phase. The XML sample parser infers structure from instance documents. The XSD parser extracts formal schema definitions. Both must produce the same FieldNode[] output as the JSON parsers from Plan 02-01.

Output: Tested XmlSampleParser and XsdParser, both conforming to BaseParser interface and producing normalized FieldNode trees.
</objective>

<execution_context>
@C:/Users/gary_/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/gary_/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-format-parser-registry/02-RESEARCH.md
@.planning/phases/02-format-parser-registry/02-01-SUMMARY.md
@src/types/parser-types.ts
@src/lib/parsers/normalize.ts
@src/lib/parsers/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement XmlSampleParser with TDD</name>
  <files>
    src/lib/parsers/xml-sample-parser.ts
    src/lib/parsers/__tests__/xml-sample-parser.test.ts
  </files>
  <action>
    **TDD approach: Write tests first (RED), then implement (GREEN).**

    **Step 1: Write XmlSampleParser tests in `src/lib/parsers/__tests__/xml-sample-parser.test.ts`.**

    Test cases:

    1. **Simple flat XML:**
       ```xml
       <order><id>123</id><total>99.99</total></order>
       ```
       → Root FieldNode "order" (type: object) with children "id" (integer) and "total" (number). Paths: "order", "order.id", "order.total".

    2. **Nested elements:**
       ```xml
       <order><customer><name>John</name><email>j@test.com</email></customer></order>
       ```
       → "order" → "customer" (object) → "name" (string), "email" (string). Paths correctly nested.

    3. **XML attributes:**
       ```xml
       <order id="123" currency="EUR"><total>99.99</total></order>
       ```
       → "order" has children including attribute nodes: "order@id" (integer), "order@currency" (string), and element "order.total" (number). Attributes use '@' in path.

    4. **Repeated elements (arrays):**
       ```xml
       <order><item><name>Widget</name></item><item><name>Gadget</name></item></order>
       ```
       → "item" detected as array type. Path: "order.item" (type: array), child: "order.item[].name" (string). Structure inferred from first element.

    5. **Mixed content (element with text + children):**
       ```xml
       <note><to>User</to><body>Hello</body></note>
       ```
       → Standard object with children.

    6. **Namespace handling:**
       ```xml
       <ns:order xmlns:ns="http://example.com"><ns:id>123</ns:id></ns:order>
       ```
       → Namespace prefixes handled — parser should either strip prefixes for clean display names or preserve them. Test that parsing does not crash and produces valid FieldNodes. Use `removeNSPrefix: true` in fast-xml-parser for cleaner names.

    7. **Empty elements:**
       ```xml
       <order><notes/></order>
       ```
       → "notes" node exists with type 'any' and empty children.

    8. **Validation — valid XML:** validate() returns `{ valid: true, errors: [] }`.

    9. **Validation — malformed XML:** validate() with unclosed tags → `{ valid: false, errors: [...] }`.

    10. **Type inference from values:** Strings that look like dates ("2024-01-15"), numbers ("42", "3.14"), booleans ("true", "false") → correct types inferred.

    **Step 2: Implement XmlSampleParser in `src/lib/parsers/xml-sample-parser.ts`.**

    - `implements BaseParser` with `readonly format: ParserType = 'xml-sample'`
    - Constructor creates `XMLParser` from fast-xml-parser with options:
      - `ignoreAttributes: false` (preserve attributes)
      - `attributeNamePrefix: '@_'` (standard prefix for attributes)
      - `parseAttributeValue: true` (auto-detect attribute types)
      - `trimValues: true`
      - `removeNSPrefix: true` (strip namespace prefixes for clean names — per research, this is simpler for display)
      - `isArray: (name, jpath, isLeafNode, isAttribute) => false` — do NOT use isArray auto-detection; instead detect arrays by checking if parsed value is already an array (fast-xml-parser auto-creates arrays for repeated elements)
    - `validate(content: string)`: Try parsing with XMLParser. Catch errors, return structured ValidationResult.
    - `parse(content: string, options?)`:
      1. Parse with XMLParser
      2. Get root element name and value
      3. Recursively build FieldNode tree:
         - For each key in parsed object:
           - If key starts with '@_': create attribute FieldNode with path `parentPath@attrName`
           - If key is '#text': skip (text content is the value, not a child)
           - If value is array: create array FieldNode, infer item structure from first element
           - If value is object: create object FieldNode with recursive children
           - If value is primitive: create leaf FieldNode with inferred type
      4. Use `normalizeType()`, `generatePath()`, `generateId()` from normalize.ts
      5. All fields have `required: false` (sample data cannot determine required)
      6. Respect options.maxDepth

    **Step 3: Run tests — all must pass (GREEN).**
  </action>
  <verify>
    Run `npx jest --testPathPattern=xml-sample` — all tests pass.
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Verify attribute handling: XML attributes appear as FieldNodes with '@' path notation.
    Verify array detection: repeated elements produce array type with `[]` in child paths.
  </verify>
  <done>
    XmlSampleParser correctly parses XML samples into FieldNode trees. Attributes, nested elements, repeated elements (arrays), and namespace-prefixed elements all handled. Type inference works for strings, numbers, integers, booleans, dates, and nulls. Validation catches malformed XML. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement XsdParser with TDD (parse XSD as XML approach)</name>
  <files>
    src/lib/parsers/xsd-parser.ts
    src/lib/parsers/__tests__/xsd-parser.test.ts
  </files>
  <action>
    **Critical context:** The research identified that extracting field structure from XSD is the hardest part of Phase 2. The approach is to parse XSD files as XML using fast-xml-parser, then walk the xs:element/xs:complexType/xs:sequence structure to build FieldNode trees. This avoids native dependencies (libxmljs2-xsd) and works in both server and client.

    **TDD approach: Write tests first (RED), then implement (GREEN).**

    **Step 1: Write XsdParser tests in `src/lib/parsers/__tests__/xsd-parser.test.ts`.**

    Test cases using inline XSD strings:

    1. **Simple element with type:**
       ```xml
       <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
         <xs:element name="order">
           <xs:complexType>
             <xs:sequence>
               <xs:element name="id" type="xs:int"/>
               <xs:element name="total" type="xs:decimal"/>
             </xs:sequence>
           </xs:complexType>
         </xs:element>
       </xs:schema>
       ```
       → Root "order" (object) with children "id" (integer) and "total" (number).

    2. **Nested complex types:**
       ```xml
       <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
         <xs:element name="order">
           <xs:complexType>
             <xs:sequence>
               <xs:element name="customer">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="name" type="xs:string"/>
                     <xs:element name="email" type="xs:string"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
             </xs:sequence>
           </xs:complexType>
         </xs:element>
       </xs:schema>
       ```
       → "order.customer.name" and "order.customer.email" paths.

    3. **Required fields (minOccurs):**
       XSD element with `minOccurs="1"` → required=true. Element with `minOccurs="0"` → required=false. Default (no minOccurs) → required=true (XSD default is 1).

    4. **Array fields (maxOccurs):**
       Element with `maxOccurs="unbounded"` → type='array' with `[]` in child paths.

    5. **XSD type mapping:**
       - xs:string → 'string'
       - xs:int, xs:integer, xs:long, xs:short → 'integer'
       - xs:decimal, xs:float, xs:double → 'number'
       - xs:boolean → 'boolean'
       - xs:date, xs:dateTime → 'date'
       - xs:anyType → 'any'

    6. **Named complex type reference:**
       ```xml
       <xs:complexType name="AddressType">
         <xs:sequence>
           <xs:element name="street" type="xs:string"/>
           <xs:element name="city" type="xs:string"/>
         </xs:sequence>
       </xs:complexType>
       <xs:element name="order">
         <xs:complexType>
           <xs:sequence>
             <xs:element name="address" type="AddressType"/>
           </xs:sequence>
         </xs:complexType>
       </xs:element>
       ```
       → "order.address.street" and "order.address.city" — named type correctly resolved.

    7. **XSD attributes:**
       ```xml
       <xs:element name="order">
         <xs:complexType>
           <xs:attribute name="currency" type="xs:string" use="required"/>
         </xs:complexType>
       </xs:element>
       ```
       → Attribute "currency" appears as FieldNode with path "order@currency", required=true.

    8. **xs:choice:** Elements within xs:choice → all included but all marked required=false (any one could appear).

    9. **Validation — valid XSD:** validate() returns valid.

    10. **Validation — malformed XML:** validate() with invalid XML → returns errors.

    11. **Validation — XML but not XSD:** validate() with regular XML (no xs:schema root) → returns error "Not a valid XSD schema".

    **Step 2: Implement XsdParser in `src/lib/parsers/xsd-parser.ts`.**

    - `implements BaseParser` with `readonly format: ParserType = 'xsd'`
    - Constructor creates `XMLParser` from fast-xml-parser with:
      - `ignoreAttributes: false`
      - `attributeNamePrefix: '@_'`
      - `removeNSPrefix: true` (strip xs: prefix for easier traversal)
      - `parseAttributeValue: false` (keep attribute values as strings)
    - `validate(content: string)`:
      1. Try XML parse
      2. Check root element is 'schema' (after namespace prefix removal)
      3. Return errors if not valid XSD
    - `parse(content: string, options?)`:
      1. Parse XSD as XML using fast-xml-parser
      2. Build a map of named complex types: find all top-level `complexType` elements with `@_name` attribute, store for later resolution
      3. Find root elements: top-level `element` entries in schema
      4. For each root element, recursively build FieldNode:
         - If element has `@_type` attribute:
           - If type is a built-in xs: type → use normalizeType()
           - If type matches a named complexType → resolve and recurse into that type's definition
         - If element has inline `complexType` child → recurse into its sequence/all/choice children
         - If element has `@_maxOccurs="unbounded"` → mark as array
         - If element has `@_minOccurs="0"` → required=false; otherwise required=true (XSD default minOccurs=1)
         - Process `sequence`, `all`, `choice` containers: extract child elements and recurse
         - Process `attribute` elements: create FieldNodes with `@` path notation, use="required" → required=true
      5. Use normalizeType(), generatePath(), generateId() from normalize.ts
      6. Respect options.maxDepth to handle recursive type definitions

    **Important implementation details:**
    - After `removeNSPrefix: true`, XSD elements become `schema`, `element`, `complexType`, `sequence`, `choice`, `all`, `attribute`, `simpleType` (no xs: prefix)
    - fast-xml-parser may wrap single children in objects vs arrays inconsistently — normalize by checking if value is array or object
    - Handle both `<xs:sequence><xs:element .../></xs:sequence>` (single element) and `<xs:sequence><xs:element .../><xs:element .../></xs:sequence>` (multiple elements)

    **Step 3: Run tests — all must pass (GREEN).**

    **Step 4: Refactor.** If XSD parsing helper functions are large, extract into private methods. Consider extracting `resolveType()` and `processCompositor()` (for sequence/choice/all).
  </action>
  <verify>
    Run `npx jest --testPathPattern=xsd-parser` — all tests pass.
    Run `npx jest` — ALL tests pass (registry + json-schema + json-sample + xml-sample + xsd).
    Run `npx tsc --noEmit` — zero TypeScript errors.
    Verify XSD type mapping: xs:string→string, xs:int→integer, xs:decimal→number, xs:date→date.
    Verify named complexType resolution works (type="AddressType" resolves correctly).
    Verify minOccurs/maxOccurs handling for required and array detection.
  </verify>
  <done>
    XsdParser correctly parses XSD schema files into FieldNode trees. Handles xs:element, xs:complexType (inline and named), xs:sequence, xs:choice, xs:attribute. Type mapping normalizes all XSD types to canonical FieldType. minOccurs controls required flag, maxOccurs="unbounded" produces array type. Named complex type references resolved. All 4 parsers now produce consistent FieldNode output. All tests pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with zero errors
2. `npx jest` shows ALL tests passing (all 4 parser test files + registry)
3. XmlSampleParser handles attributes, namespaces, repeated elements
4. XsdParser extracts structure from xs:element/xs:complexType/xs:sequence
5. XSD named type references resolved correctly
6. Both parsers use shared normalizeType() from normalize.ts
7. FieldNode output is structurally consistent across all 4 parsers
</verification>

<success_criteria>
- XmlSampleParser produces correct FieldNode[] for XML with attributes, nesting, repeated elements, and namespaces
- XsdParser produces correct FieldNode[] from XSD schema definitions including named types, sequences, choices, and attributes
- XSD minOccurs/maxOccurs correctly maps to required flag and array type
- Both parsers validate input and return errors for malformed content
- All tests pass across all 4 parsers
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-format-parser-registry/02-02-SUMMARY.md`
</output>
